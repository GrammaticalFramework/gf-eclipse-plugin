resource ConstructorsGer = open (GrammarGer = GrammarGer),(GrammarGer = GrammarGer),(GrammarGer = GrammarGer) in {
  flags
    coding = "latin1" ;
  oper Art : Type ;
  oper ComplV2 : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                  c2 : {s : Str; c : ResGer.PCase}; lock_V2 : {}; prefix : Str;
                  vtype : ResGer.VType} -> {s : ResGer.PCase => Str; a : ResGer.Agr;
                                            isPron : Prelude.Bool;
                                            lock_NP : {}} -> {s : {s : ResGer.VForm => Str;
                                                                   aux : ResGer.VAux; prefix : Str;
                                                                   vtype : ResGer.VType};
                                                              a1 : ParamX.Polarity => Str; a2 : Str;
                                                              ext : Str; inf : Str;
                                                              isAux : Prelude.Bool; lock_VP : {};
                                                              n0 : ResGer.Agr => Str;
                                                              n2 : ResGer.Agr => Str} ;
  oper ComplV2A : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                   c2 : {s : Str; c : ResGer.PCase}; lock_V2A : {}; prefix : Str;
                   vtype : ResGer.VType} -> {s : ResGer.PCase => Str; a : ResGer.Agr;
                                             isPron : Prelude.Bool;
                                             lock_NP : {}} -> {s : ResGer.AForm => Str;
                                                               isPre : Prelude.Bool;
                                                               lock_AP : {}} -> {s : {s : ResGer.VForm => Str;
                                                                                      aux : ResGer.VAux;
                                                                                      prefix : Str;
                                                                                      vtype : ResGer.VType};
                                                                                 a1 : ParamX.Polarity => Str;
                                                                                 a2 : Str;
                                                                                 ext : Str;
                                                                                 inf : Str;
                                                                                 isAux : Prelude.Bool;
                                                                                 lock_VP : {};
                                                                                 n0 : ResGer.Agr => Str;
                                                                                 n2 : ResGer.Agr => Str} ;
  oper ComplV3 : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                  c2 : {s : Str; c : ResGer.PCase}; c3 : {s : Str; c : ResGer.PCase};
                  lock_V3 : {}; prefix : Str;
                  vtype : ResGer.VType} -> {s : ResGer.PCase => Str; a : ResGer.Agr;
                                            isPron : Prelude.Bool;
                                            lock_NP : {}} -> {s : ResGer.PCase => Str;
                                                              a : ResGer.Agr; isPron : Prelude.Bool;
                                                              lock_NP : {}} -> {s : {s : ResGer.VForm => Str;
                                                                                     aux : ResGer.VAux;
                                                                                     prefix : Str;
                                                                                     vtype : ResGer.VType};
                                                                                a1 : ParamX.Polarity => Str;
                                                                                a2 : Str; ext : Str;
                                                                                inf : Str;
                                                                                isAux : Prelude.Bool;
                                                                                lock_VP : {};
                                                                                n0 : ResGer.Agr => Str;
                                                                                n2 : ResGer.Agr => Str} ;
  oper DetArtCard : {s : Prelude.Bool => ParamX.Number => ResGer.Gender => ResGer.PCase => Str;
                     a : ResGer.Adjf; lock_Quant : {};
                     sp : ParamX.Number => ResGer.Gender => ResGer.PCase => Str} -> {s : ResGer.Gender => ResGer.Case => Str;
                                                                                     lock_Card : {};
                                                                                     n : ParamX.Number} -> {s : ResGer.Gender => ResGer.PCase => Str;
                                                                                                            a : ResGer.Adjf;
                                                                                                            lock_Det : {};
                                                                                                            n : ParamX.Number;
                                                                                                            sp : ResGer.Gender => ResGer.PCase => Str} ;
  oper DetArtOrd : {s : Prelude.Bool => ParamX.Number => ResGer.Gender => ResGer.PCase => Str;
                    a : ResGer.Adjf; lock_Quant : {};
                    sp : ParamX.Number => ResGer.Gender => ResGer.PCase => Str} -> {s : ResGer.Gender => ResGer.Case => Str;
                                                                                    isNum : Prelude.Bool;
                                                                                    lock_Num : {};
                                                                                    n : ParamX.Number} -> {s : ResGer.AForm => Str;
                                                                                                           lock_Ord : {}} -> {s : ResGer.Gender => ResGer.PCase => Str;
                                                                                                                              a : ResGer.Adjf;
                                                                                                                              lock_Det : {};
                                                                                                                              n : ParamX.Number;
                                                                                                                              sp : ResGer.Gender => ResGer.PCase => Str} ;
  oper DetArtPl : {s : Prelude.Bool => ParamX.Number => ResGer.Gender => ResGer.PCase => Str;
                   a : ResGer.Adjf; lock_Quant : {};
                   sp : ParamX.Number => ResGer.Gender => ResGer.PCase => Str} -> {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                                                                   g : ResGer.Gender;
                                                                                   lock_CN : {}} -> {s : ResGer.PCase => Str;
                                                                                                     a : ResGer.Agr;
                                                                                                     isPron : Prelude.Bool;
                                                                                                     lock_NP : {}} ;
  oper DetArtSg : {s : Prelude.Bool => ParamX.Number => ResGer.Gender => ResGer.PCase => Str;
                   a : ResGer.Adjf; lock_Quant : {};
                   sp : ParamX.Number => ResGer.Gender => ResGer.PCase => Str} -> {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                                                                   g : ResGer.Gender;
                                                                                   lock_CN : {}} -> {s : ResGer.PCase => Str;
                                                                                                     a : ResGer.Agr;
                                                                                                     isPron : Prelude.Bool;
                                                                                                     lock_NP : {}} ;
  oper DetPl : {s : Prelude.Bool => ParamX.Number => ResGer.Gender => ResGer.PCase => Str;
                a : ResGer.Adjf; lock_Quant : {};
                sp : ParamX.Number => ResGer.Gender => ResGer.PCase => Str} -> {s : ResGer.Gender => ResGer.Case => Str;
                                                                                isNum : Prelude.Bool;
                                                                                lock_Num : {};
                                                                                n : ParamX.Number} -> {s : ResGer.AForm => Str;
                                                                                                       lock_Ord : {}} -> {s : ResGer.Gender => ResGer.PCase => Str;
                                                                                                                          a : ResGer.Adjf;
                                                                                                                          lock_Det : {};
                                                                                                                          n : ParamX.Number;
                                                                                                                          sp : ResGer.Gender => ResGer.PCase => Str} ;
  oper DetSg : {s : Prelude.Bool => ParamX.Number => ResGer.Gender => ResGer.PCase => Str;
                a : ResGer.Adjf; lock_Quant : {};
                sp : ParamX.Number => ResGer.Gender => ResGer.PCase => Str} -> {s : ResGer.AForm => Str;
                                                                                lock_Ord : {}} -> {s : ResGer.Gender => ResGer.PCase => Str;
                                                                                                   a : ResGer.Adjf;
                                                                                                   lock_Det : {};
                                                                                                   n : ParamX.Number;
                                                                                                   sp : ResGer.Gender => ResGer.PCase => Str} ;
  param ImpForm = IFSg | IFPl | IFPol ;
  oper ListAP : Type ;
  oper ListAdv : Type ;
  oper ListNP : Type ;
  oper ListS : Type ;
  oper PlQuant : {s : Prelude.Bool => ParamX.Number => ResGer.Gender => ResGer.PCase => Str;
                  a : ResGer.Adjf; lock_Quant : {};
                  sp : ParamX.Number => ResGer.Gender => ResGer.PCase => Str} -> {s : Prelude.Bool => ParamX.Number => ResGer.Gender => ResGer.PCase => Str;
                                                                                  a : ResGer.Adjf;
                                                                                  isPl : {};
                                                                                  lock_Quant : {};
                                                                                  sp : ParamX.Number => ResGer.Gender => ResGer.PCase => Str} ;
  param Punct = PFullStop | PExclMark | PQuestMark ;
  oper QuantPl : Type ;
  oper QuantSg : Type ;
  oper SgQuant : {s : Prelude.Bool => ParamX.Number => ResGer.Gender => ResGer.PCase => Str;
                  a : ResGer.Adjf; lock_Quant : {};
                  sp : ParamX.Number => ResGer.Gender => ResGer.PCase => Str} -> {s : Prelude.Bool => ParamX.Number => ResGer.Gender => ResGer.PCase => Str;
                                                                                  a : ResGer.Adjf;
                                                                                  isSg : {};
                                                                                  lock_Quant : {};
                                                                                  sp : ParamX.Number => ResGer.Gender => ResGer.PCase => Str} ;
  oper TUseCl : {s : Str; lock_Tense : {}; m : ResGer.Mood;
                 t : ParamX.Tense} -> {s : Str; a : ParamX.Anteriority;
                                       lock_Ant : {}} -> {s : Str; lock_Pol : {};
                                                          p : ParamX.Polarity} -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                                                   lock_Cl : {}} -> {s : ResGer.Order => Str;
                                                                                                     lock_S : {}} ;
  oper TUseQCl : {s : Str; lock_Tense : {}; m : ResGer.Mood;
                  t : ParamX.Tense} -> {s : Str; a : ParamX.Anteriority;
                                        lock_Ant : {}} -> {s : Str; lock_Pol : {};
                                                           p : ParamX.Polarity} -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ParamX.QForm => Str;
                                                                                    lock_QCl : {}} -> {s : ParamX.QForm => Str;
                                                                                                       lock_QS : {}} ;
  oper TUseRCl : {s : Str; lock_Tense : {}; m : ResGer.Mood;
                  t : ParamX.Tense} -> {s : Str; a : ParamX.Anteriority;
                                        lock_Ant : {}} -> {s : Str; lock_Pol : {};
                                                           p : ParamX.Polarity} -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.GenNum => Str;
                                                                                    c : ResGer.Case;
                                                                                    lock_RCl : {}} -> {s : ResGer.GenNum => Str;
                                                                                                       c : ResGer.Case;
                                                                                                       lock_RS : {}} ;
  oper Unit : Type ;
  oper aPl_Det : {s : ResGer.Gender => ResGer.PCase => Str;
                  a : ResGer.Adjf; lock_Det : {}; n : ParamX.Number;
                  sp : ResGer.Gender => ResGer.PCase => Str} ;
  oper aSg_Det : {s : ResGer.Gender => ResGer.PCase => Str;
                  a : ResGer.Adjf; lock_Det : {}; n : ParamX.Number;
                  sp : ResGer.Gender => ResGer.PCase => Str} ;
  oper a_Art : {s : Prelude.Bool => ParamX.Number => ResGer.Gender => ResGer.PCase => Str;
                a : ResGer.Adjf; lock_Quant : {};
                sp : ParamX.Number => ResGer.Gender => ResGer.PCase => Str} ;
  oper a_Det : {s : ResGer.Gender => ResGer.PCase => Str;
                a : ResGer.Adjf; lock_Det : {}; n : ParamX.Number;
                sp : ResGer.Gender => ResGer.PCase => Str} ;
  oper a_Quant : {s : Prelude.Bool => ParamX.Number => ResGer.Gender => ResGer.PCase => Str;
                  a : ResGer.Adjf; lock_Quant : {};
                  sp : ParamX.Number => ResGer.Gender => ResGer.PCase => Str} ;
  oper comparAP : {s : ParamX.Degree => ResGer.AForm => Str;
                   lock_A : {}} -> {s : ResGer.AForm => Str; isPre : Prelude.Bool;
                                    lock_AP : {}} ;
  oper digit : pattern Str ;
  oper emptyText : {s : Str; lock_Text : {}} ;
  oper exclMarkPunct : ConstructorsGer.Punct ;
  oper fullStopPunct : ConstructorsGer.Punct ;
  oper genericCl : {s : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                         prefix : Str; vtype : ResGer.VType};
                    a1 : ParamX.Polarity => Str; a2 : Str; ext : Str; inf : Str;
                    isAux : Prelude.Bool; lock_VP : {}; n0 : ResGer.Agr => Str;
                    n2 : ResGer.Agr => Str} -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                lock_Cl : {}} ;
  oper he_NP : {s : ResGer.PCase => Str; a : ResGer.Agr;
                isPron : Prelude.Bool; lock_NP : {}} ;
  oper i_NP : {s : ResGer.PCase => Str; a : ResGer.Agr;
               isPron : Prelude.Bool; lock_NP : {}} ;
  oper idigit : pattern Str ;
  oper it_NP : {s : ResGer.PCase => Str; a : ResGer.Agr;
                isPron : Prelude.Bool; lock_NP : {}} ;
  oper lets_Utt : {s : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                        prefix : Str; vtype : ResGer.VType};
                   a1 : ParamX.Polarity => Str; a2 : Str; ext : Str; inf : Str;
                   isAux : Prelude.Bool; lock_VP : {}; n0 : ResGer.Agr => Str;
                   n2 : ResGer.Agr => Str} -> {s : Str; lock_Utt : {}} ;
  oper mkAP = overload {
                mkAP : {s : ParamX.Degree => ResGer.AForm => Str;
                        lock_A : {}} -> {s : ResGer.AForm => Str; isPre : Prelude.Bool;
                                         lock_AP : {}}
                     = 0 ;
                mkAP : {s : ParamX.Degree => ResGer.AForm => Str;
                        lock_A : {}} -> {s : ResGer.PCase => Str; a : ResGer.Agr;
                                         isPron : Prelude.Bool;
                                         lock_NP : {}} -> {s : ResGer.AForm => Str;
                                                           isPre : Prelude.Bool; lock_AP : {}}
                     = 0 ;
                mkAP : {s : ParamX.Degree => ResGer.AForm => Str;
                        c2 : {s : Str; c : ResGer.PCase};
                        lock_A2 : {}} -> {s : ResGer.PCase => Str; a : ResGer.Agr;
                                          isPron : Prelude.Bool;
                                          lock_NP : {}} -> {s : ResGer.AForm => Str;
                                                            isPre : Prelude.Bool; lock_AP : {}}
                     = 0 ;
                mkAP : {s : ParamX.Degree => ResGer.AForm => Str;
                        c2 : {s : Str; c : ResGer.PCase};
                        lock_A2 : {}} -> {s : ResGer.AForm => Str; isPre : Prelude.Bool;
                                          lock_AP : {}}
                     = 0 ;
                mkAP : (ap : {s : ResGer.AForm => Str; isPre : Prelude.Bool;
                              lock_AP : {}}) -> (s : {s : ResGer.Order => Str;
                                                      lock_S : {}}) -> {s : ResGer.AForm => Str;
                                                                        isPre : Prelude.Bool;
                                                                        lock_AP : {}}
                     = 0 ;
                mkAP : (ap : {s : ResGer.AForm => Str; isPre : Prelude.Bool;
                              lock_AP : {}}) -> (s : {s : ParamX.QForm => Str;
                                                      lock_QS : {}}) -> {s : ResGer.AForm => Str;
                                                                         isPre : Prelude.Bool;
                                                                         lock_AP : {}}
                     = 0 ;
                mkAP : (ap : {s : ResGer.AForm => Str; isPre : Prelude.Bool;
                              lock_AP : {}}) -> (s : {s : {s : ResGer.VForm => Str;
                                                           aux : ResGer.VAux; prefix : Str;
                                                           vtype : ResGer.VType};
                                                      a1 : ParamX.Polarity => Str; a2 : Str;
                                                      ext : Str; inf : Str; isAux : Prelude.Bool;
                                                      lock_VP : {}; n0 : ResGer.Agr => Str;
                                                      n2 : ResGer.Agr => Str}) -> {s : ResGer.AForm => Str;
                                                                                   isPre : Prelude.Bool;
                                                                                   lock_AP : {}}
                     = 0 ;
                mkAP : (ap : {s : ResGer.AForm => Str; isPre : Prelude.Bool;
                              lock_AP : {}}) -> (s : {s : Str;
                                                      lock_SC : {}}) -> {s : ResGer.AForm => Str;
                                                                         isPre : Prelude.Bool;
                                                                         lock_AP : {}}
                     = 0 ;
                mkAP : (x : {s : Str;
                             lock_AdA : {}}) -> (y : {s : ParamX.Degree => ResGer.AForm => Str;
                                                      lock_A : {}}) -> {s : ResGer.AForm => Str;
                                                                        isPre : Prelude.Bool;
                                                                        lock_AP : {}}
                     = 0 ;
                mkAP : {s : Str; lock_AdA : {}} -> {s : ResGer.AForm => Str;
                                                    isPre : Prelude.Bool;
                                                    lock_AP : {}} -> {s : ResGer.AForm => Str;
                                                                      isPre : Prelude.Bool;
                                                                      lock_AP : {}}
                     = 0 ;
                mkAP : (c : {lock_Conj : {}; n : ParamX.Number; s1 : Str;
                             s2 : Str}) -> (x : {s : ResGer.AForm => Str; isPre : Prelude.Bool;
                                                 lock_AP : {}}) -> (y : {s : ResGer.AForm => Str;
                                                                         isPre : Prelude.Bool;
                                                                         lock_AP : {}}) -> {s : ResGer.AForm => Str;
                                                                                            isPre : Prelude.Bool;
                                                                                            lock_AP : {}}
                     = 0 ;
                mkAP : (c : {lock_Conj : {}; n : ParamX.Number; s1 : Str;
                             s2 : Str}) -> (xy : {isPre : Prelude.Bool; lock_ListAP : {};
                                                  s1 : ResGer.AForm => Str;
                                                  s2 : ResGer.AForm => Str}) -> {s : ResGer.AForm => Str;
                                                                                 isPre : Prelude.Bool;
                                                                                 lock_AP : {}}
                     = 0 ;
                mkAP : {s : ResGer.AForm => Str;
                        lock_Ord : {}} -> {s : ResGer.AForm => Str; isPre : Prelude.Bool;
                                           lock_AP : {}}
                     = 0 ;
                mkAP : {s : Str; lock_CAdv : {};
                        p : Str} -> {s : ResGer.AForm => Str; isPre : Prelude.Bool;
                                     lock_AP : {}} -> {s : ResGer.PCase => Str; a : ResGer.Agr;
                                                       isPron : Prelude.Bool;
                                                       lock_NP : {}} -> {s : ResGer.AForm => Str;
                                                                         isPre : Prelude.Bool;
                                                                         lock_AP : {}}
                     = 0 ;
              } ;
  oper mkAdN : {s : Str; lock_CAdv : {}; p : Str} -> {s : Str;
                                                      lock_AdN : {}} ;
  oper mkAdv = overload {
                 mkAdv : {s : ParamX.Degree => ResGer.AForm => Str;
                          lock_A : {}} -> {s : Str; lock_Adv : {}}
                       = 0 ;
                 mkAdv : {s : Str; c : ResGer.PCase;
                          lock_Prep : {}} -> {s : ResGer.PCase => Str; a : ResGer.Agr;
                                              isPron : Prelude.Bool; lock_NP : {}} -> {s : Str;
                                                                                       lock_Adv : {}}
                       = 0 ;
                 mkAdv : {s : Str; lock_Subj : {}} -> {s : ResGer.Order => Str;
                                                       lock_S : {}} -> {s : Str; lock_Adv : {}}
                       = 0 ;
                 mkAdv : {s : Str; lock_CAdv : {};
                          p : Str} -> {s : ParamX.Degree => ResGer.AForm => Str;
                                       lock_A : {}} -> {s : ResGer.PCase => Str; a : ResGer.Agr;
                                                        isPron : Prelude.Bool;
                                                        lock_NP : {}} -> {s : Str; lock_Adv : {}}
                       = 0 ;
                 mkAdv : {s : Str; lock_CAdv : {};
                          p : Str} -> {s : ParamX.Degree => ResGer.AForm => Str;
                                       lock_A : {}} -> {s : ResGer.Order => Str;
                                                        lock_S : {}} -> {s : Str; lock_Adv : {}}
                       = 0 ;
                 mkAdv : {s : Str; lock_AdA : {}} -> {s : Str;
                                                      lock_Adv : {}} -> {s : Str; lock_Adv : {}}
                       = 0 ;
                 mkAdv : (c : {lock_Conj : {}; n : ParamX.Number; s1 : Str;
                               s2 : Str}) -> (x : {s : Str; lock_Adv : {}}) -> (y : {s : Str;
                                                                                     lock_Adv : {}}) -> {s : Str;
                                                                                                         lock_Adv : {}}
                       = 0 ;
                 mkAdv : (c : {lock_Conj : {}; n : ParamX.Number; s1 : Str;
                               s2 : Str}) -> (xy : {lock_ListAdv : {}; s1 : Str;
                                                    s2 : Str}) -> {s : Str; lock_Adv : {}}
                       = 0 ;
               } ;
  oper mkCN = overload {
                mkCN : {s : ParamX.Number => ResGer.Case => Str; g : ResGer.Gender;
                        lock_N : {}} -> {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                         g : ResGer.Gender; lock_CN : {}}
                     = 0 ;
                mkCN : {s : ParamX.Number => ResGer.Case => Str;
                        c2 : {s : Str; c : ResGer.PCase}; g : ResGer.Gender;
                        lock_N2 : {}} -> {s : ResGer.PCase => Str; a : ResGer.Agr;
                                          isPron : Prelude.Bool;
                                          lock_NP : {}} -> {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                                            g : ResGer.Gender; lock_CN : {}}
                     = 0 ;
                mkCN : (f : {s : ParamX.Number => ResGer.Case => Str;
                             c2 : {s : Str; c : ResGer.PCase}; c3 : {s : Str; c : ResGer.PCase};
                             g : ResGer.Gender; lock_N3 : {}}) -> (x : {s : ResGer.PCase => Str;
                                                                        a : ResGer.Agr;
                                                                        isPron : Prelude.Bool;
                                                                        lock_NP : {}}) -> {s : ResGer.PCase => Str;
                                                                                           a : ResGer.Agr;
                                                                                           isPron : Prelude.Bool;
                                                                                           lock_NP : {}} -> {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                                                                                             g : ResGer.Gender;
                                                                                                             lock_CN : {}}
                     = 0 ;
                mkCN : {s : ParamX.Number => ResGer.Case => Str;
                        c2 : {s : Str; c : ResGer.PCase}; g : ResGer.Gender;
                        lock_N2 : {}} -> {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                          g : ResGer.Gender; lock_CN : {}}
                     = 0 ;
                mkCN : (n : {s : ParamX.Number => ResGer.Case => Str;
                             c2 : {s : Str; c : ResGer.PCase}; c3 : {s : Str; c : ResGer.PCase};
                             g : ResGer.Gender;
                             lock_N3 : {}}) -> {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                                g : ResGer.Gender; lock_CN : {}}
                     = 0 ;
                mkCN : (x : {s : ParamX.Degree => ResGer.AForm => Str;
                             lock_A : {}}) -> (y : {s : ParamX.Number => ResGer.Case => Str;
                                                    g : ResGer.Gender;
                                                    lock_N : {}}) -> {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                                                      g : ResGer.Gender;
                                                                      lock_CN : {}}
                     = 0 ;
                mkCN : (x : {s : ParamX.Degree => ResGer.AForm => Str;
                             lock_A : {}}) -> (y : {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                                    g : ResGer.Gender;
                                                    lock_CN : {}}) -> {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                                                       g : ResGer.Gender;
                                                                       lock_CN : {}}
                     = 0 ;
                mkCN : (x : {s : ResGer.AForm => Str; isPre : Prelude.Bool;
                             lock_AP : {}}) -> (y : {s : ParamX.Number => ResGer.Case => Str;
                                                     g : ResGer.Gender;
                                                     lock_N : {}}) -> {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                                                       g : ResGer.Gender;
                                                                       lock_CN : {}}
                     = 0 ;
                mkCN : {s : ResGer.AForm => Str; isPre : Prelude.Bool;
                        lock_AP : {}} -> {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                          g : ResGer.Gender;
                                          lock_CN : {}} -> {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                                            g : ResGer.Gender; lock_CN : {}}
                     = 0 ;
                mkCN : (x : {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                             g : ResGer.Gender; lock_CN : {}}) -> (y : {s : ResGer.AForm => Str;
                                                                        isPre : Prelude.Bool;
                                                                        lock_AP : {}}) -> {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                                                                           g : ResGer.Gender;
                                                                                           lock_CN : {}}
                     = 0 ;
                mkCN : (x : {s : ParamX.Number => ResGer.Case => Str;
                             g : ResGer.Gender; lock_N : {}}) -> (y : {s : ResGer.AForm => Str;
                                                                       isPre : Prelude.Bool;
                                                                       lock_AP : {}}) -> {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                                                                          g : ResGer.Gender;
                                                                                          lock_CN : {}}
                     = 0 ;
                mkCN : (x : {s : ParamX.Number => ResGer.Case => Str;
                             g : ResGer.Gender; lock_N : {}}) -> (y : {s : ResGer.GenNum => Str;
                                                                       c : ResGer.Case;
                                                                       lock_RS : {}}) -> {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                                                                          g : ResGer.Gender;
                                                                                          lock_CN : {}}
                     = 0 ;
                mkCN : {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                        g : ResGer.Gender; lock_CN : {}} -> {s : ResGer.GenNum => Str;
                                                             c : ResGer.Case;
                                                             lock_RS : {}} -> {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                                                               g : ResGer.Gender;
                                                                               lock_CN : {}}
                     = 0 ;
                mkCN : (x : {s : ParamX.Number => ResGer.Case => Str;
                             g : ResGer.Gender; lock_N : {}}) -> (y : {s : Str;
                                                                       lock_Adv : {}}) -> {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                                                                           g : ResGer.Gender;
                                                                                           lock_CN : {}}
                     = 0 ;
                mkCN : {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                        g : ResGer.Gender; lock_CN : {}} -> {s : Str;
                                                             lock_Adv : {}} -> {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                                                                g : ResGer.Gender;
                                                                                lock_CN : {}}
                     = 0 ;
                mkCN : (cn : {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                              g : ResGer.Gender; lock_CN : {}}) -> (s : {s : ResGer.Order => Str;
                                                                         lock_S : {}}) -> {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                                                                           g : ResGer.Gender;
                                                                                           lock_CN : {}}
                     = 0 ;
                mkCN : (cn : {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                              g : ResGer.Gender; lock_CN : {}}) -> (s : {s : ParamX.QForm => Str;
                                                                         lock_QS : {}}) -> {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                                                                            g : ResGer.Gender;
                                                                                            lock_CN : {}}
                     = 0 ;
                mkCN : (cn : {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                              g : ResGer.Gender;
                              lock_CN : {}}) -> (s : {s : {s : ResGer.VForm => Str;
                                                           aux : ResGer.VAux; prefix : Str;
                                                           vtype : ResGer.VType};
                                                      a1 : ParamX.Polarity => Str; a2 : Str;
                                                      ext : Str; inf : Str; isAux : Prelude.Bool;
                                                      lock_VP : {}; n0 : ResGer.Agr => Str;
                                                      n2 : ResGer.Agr => Str}) -> {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                                                                   g : ResGer.Gender;
                                                                                   lock_CN : {}}
                     = 0 ;
                mkCN : (cn : {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                              g : ResGer.Gender; lock_CN : {}}) -> (s : {s : Str;
                                                                         lock_SC : {}}) -> {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                                                                            g : ResGer.Gender;
                                                                                            lock_CN : {}}
                     = 0 ;
                mkCN : (x : {s : ParamX.Number => ResGer.Case => Str;
                             g : ResGer.Gender; lock_N : {}}) -> (y : {s : ResGer.PCase => Str;
                                                                       a : ResGer.Agr;
                                                                       isPron : Prelude.Bool;
                                                                       lock_NP : {}}) -> {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                                                                          g : ResGer.Gender;
                                                                                          lock_CN : {}}
                     = 0 ;
                mkCN : {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                        g : ResGer.Gender; lock_CN : {}} -> {s : ResGer.PCase => Str;
                                                             a : ResGer.Agr; isPron : Prelude.Bool;
                                                             lock_NP : {}} -> {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                                                               g : ResGer.Gender;
                                                                               lock_CN : {}}
                     = 0 ;
              } ;
  oper mkCard = overload {
                  mkCard : Str -> {s : ResGer.Gender => ResGer.Case => Str;
                                   lock_Card : {}; n : ParamX.Number}
                         = 0 ;
                  mkCard : {s : ResGer.CardOrd => Str; lock_Numeral : {};
                            n : ParamX.Number} -> {s : ResGer.Gender => ResGer.Case => Str;
                                                   lock_Card : {}; n : ParamX.Number}
                         = 0 ;
                  mkCard : {s : ResGer.CardOrd => Str; lock_Digits : {};
                            n : ParamX.Number} -> {s : ResGer.Gender => ResGer.Case => Str;
                                                   lock_Card : {}; n : ParamX.Number}
                         = 0 ;
                  mkCard : {s : Str;
                            lock_AdN : {}} -> {s : ResGer.Gender => ResGer.Case => Str;
                                               lock_Card : {};
                                               n : ParamX.Number} -> {s : ResGer.Gender => ResGer.Case => Str;
                                                                      lock_Card : {};
                                                                      n : ParamX.Number}
                         = 0 ;
                } ;
  oper mkCl = overload {
                mkCl : (s : {s : ResGer.PCase => Str; a : ResGer.Agr;
                             isPron : Prelude.Bool;
                             lock_NP : {}}) -> (v : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                                                     lock_V : {}; prefix : Str;
                                                     vtype : ResGer.VType}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                                                lock_Cl : {}}
                     = 0 ;
                mkCl : (s : {s : ResGer.PCase => Str; a : ResGer.Agr;
                             isPron : Prelude.Bool;
                             lock_NP : {}}) -> (v : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                                                     c2 : {s : Str; c : ResGer.PCase}; lock_V2 : {};
                                                     prefix : Str;
                                                     vtype : ResGer.VType}) -> (o : {s : ResGer.PCase => Str;
                                                                                     a : ResGer.Agr;
                                                                                     isPron : Prelude.Bool;
                                                                                     lock_NP : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                                                                        lock_Cl : {}}
                     = 0 ;
                mkCl : (s : {s : ResGer.PCase => Str; a : ResGer.Agr;
                             isPron : Prelude.Bool;
                             lock_NP : {}}) -> (v : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                                                     c2 : {s : Str; c : ResGer.PCase};
                                                     c3 : {s : Str; c : ResGer.PCase}; lock_V3 : {};
                                                     prefix : Str;
                                                     vtype : ResGer.VType}) -> (o : {s : ResGer.PCase => Str;
                                                                                     a : ResGer.Agr;
                                                                                     isPron : Prelude.Bool;
                                                                                     lock_NP : {}}) -> (i : {s : ResGer.PCase => Str;
                                                                                                             a : ResGer.Agr;
                                                                                                             isPron : Prelude.Bool;
                                                                                                             lock_NP : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                                                                                                lock_Cl : {}}
                     = 0 ;
                mkCl : (s : {s : ResGer.PCase => Str; a : ResGer.Agr;
                             isPron : Prelude.Bool;
                             lock_NP : {}}) -> (v : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                                                     isAux : Prelude.Bool; lock_VV : {};
                                                     prefix : Str;
                                                     vtype : ResGer.VType}) -> (vp : {s : {s : ResGer.VForm => Str;
                                                                                           aux : ResGer.VAux;
                                                                                           prefix : Str;
                                                                                           vtype : ResGer.VType};
                                                                                      a1 : ParamX.Polarity => Str;
                                                                                      a2 : Str;
                                                                                      ext : Str;
                                                                                      inf : Str;
                                                                                      isAux : Prelude.Bool;
                                                                                      lock_VP : {};
                                                                                      n0 : ResGer.Agr => Str;
                                                                                      n2 : ResGer.Agr => Str}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                                                                                   lock_Cl : {}}
                     = 0 ;
                mkCl : (s : {s : ResGer.PCase => Str; a : ResGer.Agr;
                             isPron : Prelude.Bool;
                             lock_NP : {}}) -> (v : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                                                     lock_VS : {}; prefix : Str;
                                                     vtype : ResGer.VType}) -> (p : {s : ResGer.Order => Str;
                                                                                     lock_S : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                                                                       lock_Cl : {}}
                     = 0 ;
                mkCl : (s : {s : ResGer.PCase => Str; a : ResGer.Agr;
                             isPron : Prelude.Bool;
                             lock_NP : {}}) -> (v : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                                                     lock_VQ : {}; prefix : Str;
                                                     vtype : ResGer.VType}) -> (q : {s : ParamX.QForm => Str;
                                                                                     lock_QS : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                                                                        lock_Cl : {}}
                     = 0 ;
                mkCl : (s : {s : ResGer.PCase => Str; a : ResGer.Agr;
                             isPron : Prelude.Bool;
                             lock_NP : {}}) -> (v : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                                                     lock_VA : {}; prefix : Str;
                                                     vtype : ResGer.VType}) -> (q : {s : ParamX.Degree => ResGer.AForm => Str;
                                                                                     lock_A : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                                                                       lock_Cl : {}}
                     = 0 ;
                mkCl : (s : {s : ResGer.PCase => Str; a : ResGer.Agr;
                             isPron : Prelude.Bool;
                             lock_NP : {}}) -> (v : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                                                     lock_VA : {}; prefix : Str;
                                                     vtype : ResGer.VType}) -> (q : {s : ResGer.AForm => Str;
                                                                                     isPre : Prelude.Bool;
                                                                                     lock_AP : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                                                                        lock_Cl : {}}
                     = 0 ;
                mkCl : (s : {s : ResGer.PCase => Str; a : ResGer.Agr;
                             isPron : Prelude.Bool;
                             lock_NP : {}}) -> (v : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                                                     c2 : {s : Str; c : ResGer.PCase};
                                                     lock_V2A : {}; prefix : Str;
                                                     vtype : ResGer.VType}) -> (n : {s : ResGer.PCase => Str;
                                                                                     a : ResGer.Agr;
                                                                                     isPron : Prelude.Bool;
                                                                                     lock_NP : {}}) -> (q : {s : ParamX.Degree => ResGer.AForm => Str;
                                                                                                             lock_A : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                                                                                               lock_Cl : {}}
                     = 0 ;
                mkCl : (s : {s : ResGer.PCase => Str; a : ResGer.Agr;
                             isPron : Prelude.Bool;
                             lock_NP : {}}) -> (v : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                                                     c2 : {s : Str; c : ResGer.PCase};
                                                     lock_V2A : {}; prefix : Str;
                                                     vtype : ResGer.VType}) -> (n : {s : ResGer.PCase => Str;
                                                                                     a : ResGer.Agr;
                                                                                     isPron : Prelude.Bool;
                                                                                     lock_NP : {}}) -> (q : {s : ResGer.AForm => Str;
                                                                                                             isPre : Prelude.Bool;
                                                                                                             lock_AP : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                                                                                                lock_Cl : {}}
                     = 0 ;
                mkCl : (s : {s : ResGer.PCase => Str; a : ResGer.Agr;
                             isPron : Prelude.Bool;
                             lock_NP : {}}) -> (v : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                                                     c2 : {s : Str; c : ResGer.PCase};
                                                     lock_V2S : {}; prefix : Str;
                                                     vtype : ResGer.VType}) -> (n : {s : ResGer.PCase => Str;
                                                                                     a : ResGer.Agr;
                                                                                     isPron : Prelude.Bool;
                                                                                     lock_NP : {}}) -> (q : {s : ResGer.Order => Str;
                                                                                                             lock_S : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                                                                                               lock_Cl : {}}
                     = 0 ;
                mkCl : (s : {s : ResGer.PCase => Str; a : ResGer.Agr;
                             isPron : Prelude.Bool;
                             lock_NP : {}}) -> (v : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                                                     c2 : {s : Str; c : ResGer.PCase};
                                                     lock_V2Q : {}; prefix : Str;
                                                     vtype : ResGer.VType}) -> (n : {s : ResGer.PCase => Str;
                                                                                     a : ResGer.Agr;
                                                                                     isPron : Prelude.Bool;
                                                                                     lock_NP : {}}) -> (q : {s : ParamX.QForm => Str;
                                                                                                             lock_QS : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                                                                                                lock_Cl : {}}
                     = 0 ;
                mkCl : (s : {s : ResGer.PCase => Str; a : ResGer.Agr;
                             isPron : Prelude.Bool;
                             lock_NP : {}}) -> (v : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                                                     c2 : {s : Str; c : ResGer.PCase};
                                                     isAux : Prelude.Bool; lock_V2V : {};
                                                     prefix : Str;
                                                     vtype : ResGer.VType}) -> (n : {s : ResGer.PCase => Str;
                                                                                     a : ResGer.Agr;
                                                                                     isPron : Prelude.Bool;
                                                                                     lock_NP : {}}) -> (q : {s : {s : ResGer.VForm => Str;
                                                                                                                  aux : ResGer.VAux;
                                                                                                                  prefix : Str;
                                                                                                                  vtype : ResGer.VType};
                                                                                                             a1 : ParamX.Polarity => Str;
                                                                                                             a2 : Str;
                                                                                                             ext : Str;
                                                                                                             inf : Str;
                                                                                                             isAux : Prelude.Bool;
                                                                                                             lock_VP : {};
                                                                                                             n0 : ResGer.Agr => Str;
                                                                                                             n2 : ResGer.Agr => Str}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                                                                                                          lock_Cl : {}}
                     = 0 ;
                mkCl : (x : {s : ResGer.PCase => Str; a : ResGer.Agr;
                             isPron : Prelude.Bool;
                             lock_NP : {}}) -> (y : {s : ParamX.Degree => ResGer.AForm => Str;
                                                     lock_A : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                                       lock_Cl : {}}
                     = 0 ;
                mkCl : (x : {s : ResGer.PCase => Str; a : ResGer.Agr;
                             isPron : Prelude.Bool;
                             lock_NP : {}}) -> (y : {s : ParamX.Degree => ResGer.AForm => Str;
                                                     lock_A : {}}) -> (z : {s : ResGer.PCase => Str;
                                                                            a : ResGer.Agr;
                                                                            isPron : Prelude.Bool;
                                                                            lock_NP : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                                                               lock_Cl : {}}
                     = 0 ;
                mkCl : (x : {s : ResGer.PCase => Str; a : ResGer.Agr;
                             isPron : Prelude.Bool;
                             lock_NP : {}}) -> (y : {s : ParamX.Degree => ResGer.AForm => Str;
                                                     c2 : {s : Str; c : ResGer.PCase};
                                                     lock_A2 : {}}) -> (z : {s : ResGer.PCase => Str;
                                                                             a : ResGer.Agr;
                                                                             isPron : Prelude.Bool;
                                                                             lock_NP : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                                                                lock_Cl : {}}
                     = 0 ;
                mkCl : (x : {s : ResGer.PCase => Str; a : ResGer.Agr;
                             isPron : Prelude.Bool;
                             lock_NP : {}}) -> (y : {s : ResGer.AForm => Str;
                                                     isPre : Prelude.Bool;
                                                     lock_AP : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                                        lock_Cl : {}}
                     = 0 ;
                mkCl : (x : {s : ResGer.PCase => Str; a : ResGer.Agr;
                             isPron : Prelude.Bool;
                             lock_NP : {}}) -> (y : {s : ResGer.PCase => Str; a : ResGer.Agr;
                                                     isPron : Prelude.Bool;
                                                     lock_NP : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                                        lock_Cl : {}}
                     = 0 ;
                mkCl : (x : {s : ResGer.PCase => Str; a : ResGer.Agr;
                             isPron : Prelude.Bool;
                             lock_NP : {}}) -> (y : {s : ParamX.Number => ResGer.Case => Str;
                                                     g : ResGer.Gender;
                                                     lock_N : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                                       lock_Cl : {}}
                     = 0 ;
                mkCl : (x : {s : ResGer.PCase => Str; a : ResGer.Agr;
                             isPron : Prelude.Bool;
                             lock_NP : {}}) -> (y : {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                                     g : ResGer.Gender;
                                                     lock_CN : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                                        lock_Cl : {}}
                     = 0 ;
                mkCl : (x : {s : ResGer.PCase => Str; a : ResGer.Agr;
                             isPron : Prelude.Bool; lock_NP : {}}) -> (y : {s : Str;
                                                                            lock_Adv : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                                                                lock_Cl : {}}
                     = 0 ;
                mkCl : {s : ResGer.PCase => Str; a : ResGer.Agr;
                        isPron : Prelude.Bool;
                        lock_NP : {}} -> {s : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                                               prefix : Str; vtype : ResGer.VType};
                                          a1 : ParamX.Polarity => Str; a2 : Str; ext : Str;
                                          inf : Str; isAux : Prelude.Bool; lock_VP : {};
                                          n0 : ResGer.Agr => Str;
                                          n2 : ResGer.Agr => Str} -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                                      lock_Cl : {}}
                     = 0 ;
                mkCl : (y : {s : ParamX.Number => ResGer.Case => Str;
                             g : ResGer.Gender;
                             lock_N : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                               lock_Cl : {}}
                     = 0 ;
                mkCl : (y : {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                             g : ResGer.Gender;
                             lock_CN : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                lock_Cl : {}}
                     = 0 ;
                mkCl : {s : ResGer.PCase => Str; a : ResGer.Agr;
                        isPron : Prelude.Bool;
                        lock_NP : {}} -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                          lock_Cl : {}}
                     = 0 ;
                mkCl : {s : ResGer.PCase => Str; a : ResGer.Agr;
                        isPron : Prelude.Bool; lock_NP : {}} -> {s : ResGer.GenNum => Str;
                                                                 c : ResGer.Case;
                                                                 lock_RS : {}} -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                                                   lock_Cl : {}}
                     = 0 ;
                mkCl : {s : Str; lock_Adv : {}} -> {s : ResGer.Order => Str;
                                                    lock_S : {}} -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                                     lock_Cl : {}}
                     = 0 ;
                mkCl : (v : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                             lock_V : {}; prefix : Str;
                             vtype : ResGer.VType}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                        lock_Cl : {}}
                     = 0 ;
                mkCl : {s : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                             prefix : Str; vtype : ResGer.VType};
                        a1 : ParamX.Polarity => Str; a2 : Str; ext : Str; inf : Str;
                        isAux : Prelude.Bool; lock_VP : {}; n0 : ResGer.Agr => Str;
                        n2 : ResGer.Agr => Str} -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                    lock_Cl : {}}
                     = 0 ;
                mkCl : {s : Str; lock_SC : {}} -> {s : {s : ResGer.VForm => Str;
                                                        aux : ResGer.VAux; prefix : Str;
                                                        vtype : ResGer.VType};
                                                   a1 : ParamX.Polarity => Str; a2 : Str; ext : Str;
                                                   inf : Str; isAux : Prelude.Bool; lock_VP : {};
                                                   n0 : ResGer.Agr => Str;
                                                   n2 : ResGer.Agr => Str} -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                                               lock_Cl : {}}
                     = 0 ;
              } ;
  oper mkClSlash = overload {
                     mkClSlash : (np : {s : ResGer.PCase => Str; a : ResGer.Agr;
                                        isPron : Prelude.Bool;
                                        lock_NP : {}}) -> (vps : {s : {s : ResGer.VForm => Str;
                                                                       aux : ResGer.VAux;
                                                                       prefix : Str;
                                                                       vtype : ResGer.VType};
                                                                  a1 : ParamX.Polarity => Str;
                                                                  a2 : Str;
                                                                  c2 : {s : Str; c : ResGer.PCase};
                                                                  ext : Str; inf : Str;
                                                                  isAux : Prelude.Bool;
                                                                  lock_VPSlash : {};
                                                                  n0 : ResGer.Agr => Str;
                                                                  n2 : ResGer.Agr => Str}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                                                               c2 : {s : Str;
                                                                                                     c : ResGer.PCase};
                                                                                               lock_ClSlash : {}}
                               = 0 ;
                     mkClSlash : (np : {s : ResGer.PCase => Str; a : ResGer.Agr;
                                        isPron : Prelude.Bool;
                                        lock_NP : {}}) -> (v2 : {s : ResGer.VForm => Str;
                                                                 aux : ResGer.VAux;
                                                                 c2 : {s : Str; c : ResGer.PCase};
                                                                 lock_V2 : {}; prefix : Str;
                                                                 vtype : ResGer.VType}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                                                            c2 : {s : Str;
                                                                                                  c : ResGer.PCase};
                                                                                            lock_ClSlash : {}}
                               = 0 ;
                     mkClSlash : (np : {s : ResGer.PCase => Str; a : ResGer.Agr;
                                        isPron : Prelude.Bool;
                                        lock_NP : {}}) -> (vv : {s : ResGer.VForm => Str;
                                                                 aux : ResGer.VAux;
                                                                 isAux : Prelude.Bool; lock_VV : {};
                                                                 prefix : Str;
                                                                 vtype : ResGer.VType}) -> (v2 : {s : ResGer.VForm => Str;
                                                                                                  aux : ResGer.VAux;
                                                                                                  c2 : {s : Str;
                                                                                                        c : ResGer.PCase};
                                                                                                  lock_V2 : {};
                                                                                                  prefix : Str;
                                                                                                  vtype : ResGer.VType}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                                                                                             c2 : {s : Str;
                                                                                                                                   c : ResGer.PCase};
                                                                                                                             lock_ClSlash : {}}
                               = 0 ;
                     mkClSlash : {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                  lock_Cl : {}} -> {s : Str; c : ResGer.PCase;
                                                    lock_Prep : {}} -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                                        c2 : {s : Str;
                                                                              c : ResGer.PCase};
                                                                        lock_ClSlash : {}}
                               = 0 ;
                     mkClSlash : {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                  c2 : {s : Str; c : ResGer.PCase}; lock_ClSlash : {}} -> {s : Str;
                                                                                           lock_Adv : {}} -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                                                                              c2 : {s : Str;
                                                                                                                    c : ResGer.PCase};
                                                                                                              lock_ClSlash : {}}
                               = 0 ;
                     mkClSlash : {s : ResGer.PCase => Str; a : ResGer.Agr;
                                  isPron : Prelude.Bool; lock_NP : {}} -> {s : ResGer.VForm => Str;
                                                                           aux : ResGer.VAux;
                                                                           lock_VS : {};
                                                                           prefix : Str;
                                                                           vtype : ResGer.VType} -> {s : ResGer.Order => Str;
                                                                                                     c2 : {s : Str;
                                                                                                           c : ResGer.PCase};
                                                                                                     lock_SSlash : {}} -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                                                                                           c2 : {s : Str;
                                                                                                                                 c : ResGer.PCase};
                                                                                                                           lock_ClSlash : {}}
                               = 0 ;
                   } ;
  oper mkComp = overload {
                  mkComp : {s : ResGer.AForm => Str; isPre : Prelude.Bool;
                            lock_AP : {}} -> {s : ResGer.Agr => Str; lock_Comp : {}}
                         = 0 ;
                  mkComp : {s : ResGer.PCase => Str; a : ResGer.Agr;
                            isPron : Prelude.Bool; lock_NP : {}} -> {s : ResGer.Agr => Str;
                                                                     lock_Comp : {}}
                         = 0 ;
                  mkComp : {s : Str; lock_Adv : {}} -> {s : ResGer.Agr => Str;
                                                        lock_Comp : {}}
                         = 0 ;
                } ;
  oper mkDet = overload {
                 mkDet : (q : {s : Prelude.Bool => ParamX.Number => ResGer.Gender => ResGer.PCase => Str;
                               a : ResGer.Adjf; lock_Quant : {};
                               sp : ParamX.Number => ResGer.Gender => ResGer.PCase => Str}) -> {s : ResGer.Gender => ResGer.PCase => Str;
                                                                                                a : ResGer.Adjf;
                                                                                                lock_Det : {};
                                                                                                n : ParamX.Number;
                                                                                                sp : ResGer.Gender => ResGer.PCase => Str}
                       = 0 ;
                 mkDet : (d : {s : Prelude.Bool => ParamX.Number => ResGer.Gender => ResGer.PCase => Str;
                               a : ResGer.Adjf; lock_Quant : {};
                               sp : ParamX.Number => ResGer.Gender => ResGer.PCase => Str}) -> (nu : {s : ResGer.Gender => ResGer.Case => Str;
                                                                                                      lock_Card : {};
                                                                                                      n : ParamX.Number}) -> {s : ResGer.Gender => ResGer.PCase => Str;
                                                                                                                              a : ResGer.Adjf;
                                                                                                                              lock_Det : {};
                                                                                                                              n : ParamX.Number;
                                                                                                                              sp : ResGer.Gender => ResGer.PCase => Str}
                       = 0 ;
                 mkDet : (q : {s : Prelude.Bool => ParamX.Number => ResGer.Gender => ResGer.PCase => Str;
                               a : ResGer.Adjf; lock_Quant : {};
                               sp : ParamX.Number => ResGer.Gender => ResGer.PCase => Str}) -> (o : {s : ResGer.AForm => Str;
                                                                                                     lock_Ord : {}}) -> {s : ResGer.Gender => ResGer.PCase => Str;
                                                                                                                         a : ResGer.Adjf;
                                                                                                                         lock_Det : {};
                                                                                                                         n : ParamX.Number;
                                                                                                                         sp : ResGer.Gender => ResGer.PCase => Str}
                       = 0 ;
                 mkDet : {s : Prelude.Bool => ParamX.Number => ResGer.Gender => ResGer.PCase => Str;
                          a : ResGer.Adjf; lock_Quant : {};
                          sp : ParamX.Number => ResGer.Gender => ResGer.PCase => Str} -> {s : ResGer.Gender => ResGer.Case => Str;
                                                                                          isNum : Prelude.Bool;
                                                                                          lock_Num : {};
                                                                                          n : ParamX.Number} -> {s : ResGer.AForm => Str;
                                                                                                                 lock_Ord : {}} -> {s : ResGer.Gender => ResGer.PCase => Str;
                                                                                                                                    a : ResGer.Adjf;
                                                                                                                                    lock_Det : {};
                                                                                                                                    n : ParamX.Number;
                                                                                                                                    sp : ResGer.Gender => ResGer.PCase => Str}
                       = 0 ;
                 mkDet : {s : Prelude.Bool => ParamX.Number => ResGer.Gender => ResGer.PCase => Str;
                          a : ResGer.Adjf; lock_Quant : {};
                          sp : ParamX.Number => ResGer.Gender => ResGer.PCase => Str} -> {s : ResGer.Gender => ResGer.Case => Str;
                                                                                          isNum : Prelude.Bool;
                                                                                          lock_Num : {};
                                                                                          n : ParamX.Number} -> {s : ResGer.Gender => ResGer.PCase => Str;
                                                                                                                 a : ResGer.Adjf;
                                                                                                                 lock_Det : {};
                                                                                                                 n : ParamX.Number;
                                                                                                                 sp : ResGer.Gender => ResGer.PCase => Str}
                       = 0 ;
                 mkDet : {s : ResGer.Gender => ResGer.Case => Str; lock_Card : {};
                          n : ParamX.Number} -> {s : ResGer.Gender => ResGer.PCase => Str;
                                                 a : ResGer.Adjf; lock_Det : {}; n : ParamX.Number;
                                                 sp : ResGer.Gender => ResGer.PCase => Str}
                       = 0 ;
                 mkDet : (d : {s : ResGer.CardOrd => Str; lock_Digits : {};
                               n : ParamX.Number}) -> {s : ResGer.Gender => ResGer.PCase => Str;
                                                       a : ResGer.Adjf; lock_Det : {};
                                                       n : ParamX.Number;
                                                       sp : ResGer.Gender => ResGer.PCase => Str}
                       = 0 ;
                 mkDet : (d : {s : ResGer.CardOrd => Str; lock_Numeral : {};
                               n : ParamX.Number}) -> {s : ResGer.Gender => ResGer.PCase => Str;
                                                       a : ResGer.Adjf; lock_Det : {};
                                                       n : ParamX.Number;
                                                       sp : ResGer.Gender => ResGer.PCase => Str}
                       = 0 ;
                 mkDet : (p : {s : ResGer.NPForm => Str; a : ResGer.Agr;
                               lock_Pron : {}}) -> {s : ResGer.Gender => ResGer.PCase => Str;
                                                    a : ResGer.Adjf; lock_Det : {};
                                                    n : ParamX.Number;
                                                    sp : ResGer.Gender => ResGer.PCase => Str}
                       = 0 ;
                 mkDet : (p : {s : ResGer.NPForm => Str; a : ResGer.Agr;
                               lock_Pron : {}}) -> {s : ResGer.Gender => ResGer.Case => Str;
                                                    isNum : Prelude.Bool; lock_Num : {};
                                                    n : ParamX.Number} -> {s : ResGer.Gender => ResGer.PCase => Str;
                                                                           a : ResGer.Adjf;
                                                                           lock_Det : {};
                                                                           n : ParamX.Number;
                                                                           sp : ResGer.Gender => ResGer.PCase => Str}
                       = 0 ;
               } ;
  oper mkDigits = overload {
                    mkDigits : Str -> {s : ResGer.CardOrd => Str; lock_Digits : {};
                                       n : ParamX.Number}
                             = 0 ;
                    mkDigits : {s : ResGer.CardOrd => Str; lock_Dig : {};
                                n : ParamX.Number} -> {s : ResGer.CardOrd => Str; lock_Digits : {};
                                                       n : ParamX.Number}
                             = 0 ;
                    mkDigits : {s : ResGer.CardOrd => Str; lock_Dig : {};
                                n : ParamX.Number} -> {s : ResGer.CardOrd => Str; lock_Digits : {};
                                                       n : ParamX.Number} -> {s : ResGer.CardOrd => Str;
                                                                              lock_Digits : {};
                                                                              n : ParamX.Number}
                             = 0 ;
                  } ;
  oper mkIAdv = overload {
                  mkIAdv : {s : Str; c : ResGer.PCase;
                            lock_Prep : {}} -> {s : ResGer.Case => Str; lock_IP : {};
                                                n : ParamX.Number} -> {s : Str; lock_IAdv : {}}
                         = 0 ;
                  mkIAdv : {s : Str; lock_IAdv : {}} -> {s : Str;
                                                         lock_Adv : {}} -> {s : Str; lock_IAdv : {}}
                         = 0 ;
                } ;
  oper mkIComp = overload {
                   mkIComp : {s : Str; lock_IAdv : {}} -> {s : ResGer.Agr => Str;
                                                           lock_IComp : {}}
                           = 0 ;
                   mkIComp : {s : ResGer.Case => Str; lock_IP : {};
                              n : ParamX.Number} -> {s : ResGer.Agr => Str; lock_IComp : {}}
                           = 0 ;
                 } ;
  oper mkIDet = overload {
                  mkIDet : (i : {s : ParamX.Number => ResGer.Gender => ResGer.Case => Str;
                                 lock_IQuant : {}}) -> (nu : {s : ResGer.Gender => ResGer.Case => Str;
                                                              isNum : Prelude.Bool; lock_Num : {};
                                                              n : ParamX.Number}) -> {s : ResGer.Gender => ResGer.Case => Str;
                                                                                      lock_IDet : {};
                                                                                      n : ParamX.Number}
                         = 0 ;
                  mkIDet : (i : {s : ParamX.Number => ResGer.Gender => ResGer.Case => Str;
                                 lock_IQuant : {}}) -> {s : ResGer.Gender => ResGer.Case => Str;
                                                        lock_IDet : {}; n : ParamX.Number}
                         = 0 ;
                } ;
  oper mkIP = overload {
                mkIP : {s : ResGer.Gender => ResGer.Case => Str; lock_IDet : {};
                        n : ParamX.Number} -> {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                               g : ResGer.Gender;
                                               lock_CN : {}} -> {s : ResGer.Case => Str;
                                                                 lock_IP : {}; n : ParamX.Number}
                     = 0 ;
                mkIP : (i : {s : ResGer.Gender => ResGer.Case => Str;
                             lock_IDet : {};
                             n : ParamX.Number}) -> (n : {s : ParamX.Number => ResGer.Case => Str;
                                                          g : ResGer.Gender;
                                                          lock_N : {}}) -> {s : ResGer.Case => Str;
                                                                            lock_IP : {};
                                                                            n : ParamX.Number}
                     = 0 ;
                mkIP : {s : ResGer.Gender => ResGer.Case => Str; lock_IDet : {};
                        n : ParamX.Number} -> {s : ResGer.Case => Str; lock_IP : {};
                                               n : ParamX.Number}
                     = 0 ;
                mkIP : (i : {s : ParamX.Number => ResGer.Gender => ResGer.Case => Str;
                             lock_IQuant : {}}) -> (n : {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                                         g : ResGer.Gender;
                                                         lock_CN : {}}) -> {s : ResGer.Case => Str;
                                                                            lock_IP : {};
                                                                            n : ParamX.Number}
                     = 0 ;
                mkIP : (i : {s : ParamX.Number => ResGer.Gender => ResGer.Case => Str;
                             lock_IQuant : {}}) -> (nu : {s : ResGer.Gender => ResGer.Case => Str;
                                                          isNum : Prelude.Bool; lock_Num : {};
                                                          n : ParamX.Number}) -> (n : {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                                                                       g : ResGer.Gender;
                                                                                       lock_CN : {}}) -> {s : ResGer.Case => Str;
                                                                                                          lock_IP : {};
                                                                                                          n : ParamX.Number}
                     = 0 ;
                mkIP : (i : {s : ParamX.Number => ResGer.Gender => ResGer.Case => Str;
                             lock_IQuant : {}}) -> (n : {s : ParamX.Number => ResGer.Case => Str;
                                                         g : ResGer.Gender;
                                                         lock_N : {}}) -> {s : ResGer.Case => Str;
                                                                           lock_IP : {};
                                                                           n : ParamX.Number}
                     = 0 ;
                mkIP : {s : ResGer.Case => Str; lock_IP : {};
                        n : ParamX.Number} -> {s : Str;
                                               lock_Adv : {}} -> {s : ResGer.Case => Str;
                                                                  lock_IP : {}; n : ParamX.Number}
                     = 0 ;
              } ;
  oper mkImp = overload {
                 mkImp : {s : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                               prefix : Str; vtype : ResGer.VType};
                          a1 : ParamX.Polarity => Str; a2 : Str; ext : Str; inf : Str;
                          isAux : Prelude.Bool; lock_VP : {}; n0 : ResGer.Agr => Str;
                          n2 : ResGer.Agr => Str} -> {s : ParamX.Polarity => ParamX.ImpForm => Str;
                                                      lock_Imp : {}}
                       = 0 ;
                 mkImp : (v : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                               lock_V : {}; prefix : Str;
                               vtype : ResGer.VType}) -> {s : ParamX.Polarity => ParamX.ImpForm => Str;
                                                          lock_Imp : {}}
                       = 0 ;
                 mkImp : (v : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                               c2 : {s : Str; c : ResGer.PCase}; lock_V2 : {}; prefix : Str;
                               vtype : ResGer.VType}) -> (np : {s : ResGer.PCase => Str;
                                                                a : ResGer.Agr;
                                                                isPron : Prelude.Bool;
                                                                lock_NP : {}}) -> {s : ParamX.Polarity => ParamX.ImpForm => Str;
                                                                                   lock_Imp : {}}
                       = 0 ;
               } ;
  oper mkListAP = overload {
                    mkListAP : {s : ResGer.AForm => Str; isPre : Prelude.Bool;
                                lock_AP : {}} -> {s : ResGer.AForm => Str; isPre : Prelude.Bool;
                                                  lock_AP : {}} -> {isPre : Prelude.Bool;
                                                                    lock_ListAP : {};
                                                                    s1 : ResGer.AForm => Str;
                                                                    s2 : ResGer.AForm => Str}
                             = 0 ;
                    mkListAP : {s : ResGer.AForm => Str; isPre : Prelude.Bool;
                                lock_AP : {}} -> {isPre : Prelude.Bool; lock_ListAP : {};
                                                  s1 : ResGer.AForm => Str;
                                                  s2 : ResGer.AForm => Str} -> {isPre : Prelude.Bool;
                                                                                lock_ListAP : {};
                                                                                s1 : ResGer.AForm => Str;
                                                                                s2 : ResGer.AForm => Str}
                             = 0 ;
                  } ;
  oper mkListAdv = overload {
                     mkListAdv : {s : Str; lock_Adv : {}} -> {s : Str;
                                                              lock_Adv : {}} -> {lock_ListAdv : {};
                                                                                 s1 : Str; s2 : Str}
                               = 0 ;
                     mkListAdv : {s : Str; lock_Adv : {}} -> {lock_ListAdv : {};
                                                              s1 : Str;
                                                              s2 : Str} -> {lock_ListAdv : {};
                                                                            s1 : Str; s2 : Str}
                               = 0 ;
                   } ;
  oper mkListNP = overload {
                    mkListNP : {s : ResGer.PCase => Str; a : ResGer.Agr;
                                isPron : Prelude.Bool; lock_NP : {}} -> {s : ResGer.PCase => Str;
                                                                         a : ResGer.Agr;
                                                                         isPron : Prelude.Bool;
                                                                         lock_NP : {}} -> {a : ResGer.Agr;
                                                                                           lock_ListNP : {};
                                                                                           s1 : ResGer.PCase => Str;
                                                                                           s2 : ResGer.PCase => Str}
                             = 0 ;
                    mkListNP : {s : ResGer.PCase => Str; a : ResGer.Agr;
                                isPron : Prelude.Bool; lock_NP : {}} -> {a : ResGer.Agr;
                                                                         lock_ListNP : {};
                                                                         s1 : ResGer.PCase => Str;
                                                                         s2 : ResGer.PCase => Str} -> {a : ResGer.Agr;
                                                                                                       lock_ListNP : {};
                                                                                                       s1 : ResGer.PCase => Str;
                                                                                                       s2 : ResGer.PCase => Str}
                             = 0 ;
                  } ;
  oper mkListRS = overload {
                    mkListRS : {s : ResGer.GenNum => Str; c : ResGer.Case;
                                lock_RS : {}} -> {s : ResGer.GenNum => Str; c : ResGer.Case;
                                                  lock_RS : {}} -> {c : ResGer.Case;
                                                                    lock_ListRS : {};
                                                                    s1 : ResGer.GenNum => Str;
                                                                    s2 : ResGer.GenNum => Str}
                             = 0 ;
                    mkListRS : {s : ResGer.GenNum => Str; c : ResGer.Case;
                                lock_RS : {}} -> {c : ResGer.Case; lock_ListRS : {};
                                                  s1 : ResGer.GenNum => Str;
                                                  s2 : ResGer.GenNum => Str} -> {c : ResGer.Case;
                                                                                 lock_ListRS : {};
                                                                                 s1 : ResGer.GenNum => Str;
                                                                                 s2 : ResGer.GenNum => Str}
                             = 0 ;
                  } ;
  oper mkListS = overload {
                   mkListS : {s : ResGer.Order => Str;
                              lock_S : {}} -> {s : ResGer.Order => Str;
                                               lock_S : {}} -> {lock_ListS : {};
                                                                s1 : ResGer.Order => Str;
                                                                s2 : ResGer.Order => Str}
                           = 0 ;
                   mkListS : {s : ResGer.Order => Str;
                              lock_S : {}} -> {lock_ListS : {}; s1 : ResGer.Order => Str;
                                               s2 : ResGer.Order => Str} -> {lock_ListS : {};
                                                                             s1 : ResGer.Order => Str;
                                                                             s2 : ResGer.Order => Str}
                           = 0 ;
                 } ;
  oper mkNP = overload {
                mkNP : (q : {s : Prelude.Bool => ParamX.Number => ResGer.Gender => ResGer.PCase => Str;
                             a : ResGer.Adjf; lock_Quant : {};
                             sp : ParamX.Number => ResGer.Gender => ResGer.PCase => Str}) -> (n : {s : ParamX.Number => ResGer.Case => Str;
                                                                                                   g : ResGer.Gender;
                                                                                                   lock_N : {}}) -> {s : ResGer.PCase => Str;
                                                                                                                     a : ResGer.Agr;
                                                                                                                     isPron : Prelude.Bool;
                                                                                                                     lock_NP : {}}
                     = 0 ;
                mkNP : (q : {s : Prelude.Bool => ParamX.Number => ResGer.Gender => ResGer.PCase => Str;
                             a : ResGer.Adjf; lock_Quant : {};
                             sp : ParamX.Number => ResGer.Gender => ResGer.PCase => Str}) -> (n : {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                                                                                   g : ResGer.Gender;
                                                                                                   lock_CN : {}}) -> {s : ResGer.PCase => Str;
                                                                                                                      a : ResGer.Agr;
                                                                                                                      isPron : Prelude.Bool;
                                                                                                                      lock_NP : {}}
                     = 0 ;
                mkNP : (q : {s : Prelude.Bool => ParamX.Number => ResGer.Gender => ResGer.PCase => Str;
                             a : ResGer.Adjf; lock_Quant : {};
                             sp : ParamX.Number => ResGer.Gender => ResGer.PCase => Str}) -> (nu : {s : ResGer.Gender => ResGer.Case => Str;
                                                                                                    isNum : Prelude.Bool;
                                                                                                    lock_Num : {};
                                                                                                    n : ParamX.Number}) -> (n : {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                                                                                                                 g : ResGer.Gender;
                                                                                                                                 lock_CN : {}}) -> {s : ResGer.PCase => Str;
                                                                                                                                                    a : ResGer.Agr;
                                                                                                                                                    isPron : Prelude.Bool;
                                                                                                                                                    lock_NP : {}}
                     = 0 ;
                mkNP : (q : {s : Prelude.Bool => ParamX.Number => ResGer.Gender => ResGer.PCase => Str;
                             a : ResGer.Adjf; lock_Quant : {};
                             sp : ParamX.Number => ResGer.Gender => ResGer.PCase => Str}) -> (nu : {s : ResGer.Gender => ResGer.Case => Str;
                                                                                                    isNum : Prelude.Bool;
                                                                                                    lock_Num : {};
                                                                                                    n : ParamX.Number}) -> (or : {s : ResGer.AForm => Str;
                                                                                                                                  lock_Ord : {}}) -> (n : {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                                                                                                                                           g : ResGer.Gender;
                                                                                                                                                           lock_CN : {}}) -> {s : ResGer.PCase => Str;
                                                                                                                                                                              a : ResGer.Agr;
                                                                                                                                                                              isPron : Prelude.Bool;
                                                                                                                                                                              lock_NP : {}}
                     = 0 ;
                mkNP : (q : {s : Prelude.Bool => ParamX.Number => ResGer.Gender => ResGer.PCase => Str;
                             a : ResGer.Adjf; lock_Quant : {};
                             sp : ParamX.Number => ResGer.Gender => ResGer.PCase => Str}) -> (nu : {s : ResGer.Gender => ResGer.Case => Str;
                                                                                                    isNum : Prelude.Bool;
                                                                                                    lock_Num : {};
                                                                                                    n : ParamX.Number}) -> (n : {s : ParamX.Number => ResGer.Case => Str;
                                                                                                                                 g : ResGer.Gender;
                                                                                                                                 lock_N : {}}) -> {s : ResGer.PCase => Str;
                                                                                                                                                   a : ResGer.Agr;
                                                                                                                                                   isPron : Prelude.Bool;
                                                                                                                                                   lock_NP : {}}
                     = 0 ;
                mkNP : {s : ResGer.Gender => ResGer.PCase => Str; a : ResGer.Adjf;
                        lock_Det : {}; n : ParamX.Number;
                        sp : ResGer.Gender => ResGer.PCase => Str} -> {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                                                       g : ResGer.Gender;
                                                                       lock_CN : {}} -> {s : ResGer.PCase => Str;
                                                                                         a : ResGer.Agr;
                                                                                         isPron : Prelude.Bool;
                                                                                         lock_NP : {}}
                     = 0 ;
                mkNP : (d : {s : ResGer.Gender => ResGer.PCase => Str;
                             a : ResGer.Adjf; lock_Det : {}; n : ParamX.Number;
                             sp : ResGer.Gender => ResGer.PCase => Str}) -> (n : {s : ParamX.Number => ResGer.Case => Str;
                                                                                  g : ResGer.Gender;
                                                                                  lock_N : {}}) -> {s : ResGer.PCase => Str;
                                                                                                    a : ResGer.Agr;
                                                                                                    isPron : Prelude.Bool;
                                                                                                    lock_NP : {}}
                     = 0 ;
                mkNP : (d : {s : ResGer.CardOrd => Str; lock_Numeral : {};
                             n : ParamX.Number}) -> (n : {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                                          g : ResGer.Gender;
                                                          lock_CN : {}}) -> {s : ResGer.PCase => Str;
                                                                             a : ResGer.Agr;
                                                                             isPron : Prelude.Bool;
                                                                             lock_NP : {}}
                     = 0 ;
                mkNP : (d : {s : ResGer.CardOrd => Str; lock_Numeral : {};
                             n : ParamX.Number}) -> (n : {s : ParamX.Number => ResGer.Case => Str;
                                                          g : ResGer.Gender;
                                                          lock_N : {}}) -> {s : ResGer.PCase => Str;
                                                                            a : ResGer.Agr;
                                                                            isPron : Prelude.Bool;
                                                                            lock_NP : {}}
                     = 0 ;
                mkNP : (d : {s : ResGer.CardOrd => Str; lock_Digits : {};
                             n : ParamX.Number}) -> (n : {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                                          g : ResGer.Gender;
                                                          lock_CN : {}}) -> {s : ResGer.PCase => Str;
                                                                             a : ResGer.Agr;
                                                                             isPron : Prelude.Bool;
                                                                             lock_NP : {}}
                     = 0 ;
                mkNP : (d : {s : ResGer.CardOrd => Str; lock_Digits : {};
                             n : ParamX.Number}) -> (n : {s : ParamX.Number => ResGer.Case => Str;
                                                          g : ResGer.Gender;
                                                          lock_N : {}}) -> {s : ResGer.PCase => Str;
                                                                            a : ResGer.Agr;
                                                                            isPron : Prelude.Bool;
                                                                            lock_NP : {}}
                     = 0 ;
                mkNP : (d : {s : ResGer.DForm => ResGer.CardOrd => Str;
                             lock_Digit : {}}) -> (n : {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                                        g : ResGer.Gender;
                                                        lock_CN : {}}) -> {s : ResGer.PCase => Str;
                                                                           a : ResGer.Agr;
                                                                           isPron : Prelude.Bool;
                                                                           lock_NP : {}}
                     = 0 ;
                mkNP : (d : {s : ResGer.DForm => ResGer.CardOrd => Str;
                             lock_Digit : {}}) -> (n : {s : ParamX.Number => ResGer.Case => Str;
                                                        g : ResGer.Gender;
                                                        lock_N : {}}) -> {s : ResGer.PCase => Str;
                                                                          a : ResGer.Agr;
                                                                          isPron : Prelude.Bool;
                                                                          lock_NP : {}}
                     = 0 ;
                mkNP : (d : {s : ResGer.Gender => ResGer.Case => Str;
                             lock_Card : {};
                             n : ParamX.Number}) -> (n : {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                                          g : ResGer.Gender;
                                                          lock_CN : {}}) -> {s : ResGer.PCase => Str;
                                                                             a : ResGer.Agr;
                                                                             isPron : Prelude.Bool;
                                                                             lock_NP : {}}
                     = 0 ;
                mkNP : (d : {s : ResGer.Gender => ResGer.Case => Str;
                             lock_Card : {};
                             n : ParamX.Number}) -> (n : {s : ParamX.Number => ResGer.Case => Str;
                                                          g : ResGer.Gender;
                                                          lock_N : {}}) -> {s : ResGer.PCase => Str;
                                                                            a : ResGer.Agr;
                                                                            isPron : Prelude.Bool;
                                                                            lock_NP : {}}
                     = 0 ;
                mkNP : (p : {s : ResGer.NPForm => Str; a : ResGer.Agr;
                             lock_Pron : {}}) -> (n : {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                                       g : ResGer.Gender;
                                                       lock_CN : {}}) -> {s : ResGer.PCase => Str;
                                                                          a : ResGer.Agr;
                                                                          isPron : Prelude.Bool;
                                                                          lock_NP : {}}
                     = 0 ;
                mkNP : (p : {s : ResGer.NPForm => Str; a : ResGer.Agr;
                             lock_Pron : {}}) -> (n : {s : ParamX.Number => ResGer.Case => Str;
                                                       g : ResGer.Gender;
                                                       lock_N : {}}) -> {s : ResGer.PCase => Str;
                                                                         a : ResGer.Agr;
                                                                         isPron : Prelude.Bool;
                                                                         lock_NP : {}}
                     = 0 ;
                mkNP : {s : ResGer.Case => Str;
                        lock_PN : {}} -> {s : ResGer.PCase => Str; a : ResGer.Agr;
                                          isPron : Prelude.Bool; lock_NP : {}}
                     = 0 ;
                mkNP : {s : ResGer.NPForm => Str; a : ResGer.Agr;
                        lock_Pron : {}} -> {s : ResGer.PCase => Str; a : ResGer.Agr;
                                            isPron : Prelude.Bool; lock_NP : {}}
                     = 0 ;
                mkNP : (q : {s : Prelude.Bool => ParamX.Number => ResGer.Gender => ResGer.PCase => Str;
                             a : ResGer.Adjf; lock_Quant : {};
                             sp : ParamX.Number => ResGer.Gender => ResGer.PCase => Str}) -> {s : ResGer.PCase => Str;
                                                                                              a : ResGer.Agr;
                                                                                              isPron : Prelude.Bool;
                                                                                              lock_NP : {}}
                     = 0 ;
                mkNP : (q : {s : Prelude.Bool => ParamX.Number => ResGer.Gender => ResGer.PCase => Str;
                             a : ResGer.Adjf; lock_Quant : {};
                             sp : ParamX.Number => ResGer.Gender => ResGer.PCase => Str}) -> (n : {s : ResGer.Gender => ResGer.Case => Str;
                                                                                                   isNum : Prelude.Bool;
                                                                                                   lock_Num : {};
                                                                                                   n : ParamX.Number}) -> {s : ResGer.PCase => Str;
                                                                                                                           a : ResGer.Agr;
                                                                                                                           isPron : Prelude.Bool;
                                                                                                                           lock_NP : {}}
                     = 0 ;
                mkNP : {s : ResGer.Gender => ResGer.PCase => Str; a : ResGer.Adjf;
                        lock_Det : {}; n : ParamX.Number;
                        sp : ResGer.Gender => ResGer.PCase => Str} -> {s : ResGer.PCase => Str;
                                                                       a : ResGer.Agr;
                                                                       isPron : Prelude.Bool;
                                                                       lock_NP : {}}
                     = 0 ;
                mkNP : {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                        g : ResGer.Gender; lock_CN : {}} -> {s : ResGer.PCase => Str;
                                                             a : ResGer.Agr; isPron : Prelude.Bool;
                                                             lock_NP : {}}
                     = 0 ;
                mkNP : (n : {s : ParamX.Number => ResGer.Case => Str;
                             g : ResGer.Gender; lock_N : {}}) -> {s : ResGer.PCase => Str;
                                                                  a : ResGer.Agr;
                                                                  isPron : Prelude.Bool;
                                                                  lock_NP : {}}
                     = 0 ;
                mkNP : {s : ParamX.Number => ResGer.Gender => ResGer.PCase => Str;
                        a : ResGer.PredetAgr; c : {k : ResGer.PredetCase; p : Str};
                        lock_Predet : {}} -> {s : ResGer.PCase => Str; a : ResGer.Agr;
                                              isPron : Prelude.Bool;
                                              lock_NP : {}} -> {s : ResGer.PCase => Str;
                                                                a : ResGer.Agr;
                                                                isPron : Prelude.Bool; lock_NP : {}}
                     = 0 ;
                mkNP : {s : ResGer.PCase => Str; a : ResGer.Agr;
                        isPron : Prelude.Bool; lock_NP : {}} -> {s : ResGer.VForm => Str;
                                                                 aux : ResGer.VAux;
                                                                 c2 : {s : Str; c : ResGer.PCase};
                                                                 lock_V2 : {}; prefix : Str;
                                                                 vtype : ResGer.VType} -> {s : ResGer.PCase => Str;
                                                                                           a : ResGer.Agr;
                                                                                           isPron : Prelude.Bool;
                                                                                           lock_NP : {}}
                     = 0 ;
                mkNP : {s : ResGer.PCase => Str; a : ResGer.Agr;
                        isPron : Prelude.Bool; lock_NP : {}} -> {s : Str;
                                                                 lock_Adv : {}} -> {s : ResGer.PCase => Str;
                                                                                    a : ResGer.Agr;
                                                                                    isPron : Prelude.Bool;
                                                                                    lock_NP : {}}
                     = 0 ;
                mkNP : {s : ResGer.PCase => Str; a : ResGer.Agr;
                        isPron : Prelude.Bool; lock_NP : {}} -> {s : ResGer.GenNum => Str;
                                                                 c : ResGer.Case;
                                                                 lock_RS : {}} -> {s : ResGer.PCase => Str;
                                                                                   a : ResGer.Agr;
                                                                                   isPron : Prelude.Bool;
                                                                                   lock_NP : {}}
                     = 0 ;
                mkNP : (c : {lock_Conj : {}; n : ParamX.Number; s1 : Str;
                             s2 : Str}) -> (x : {s : ResGer.PCase => Str; a : ResGer.Agr;
                                                 isPron : Prelude.Bool;
                                                 lock_NP : {}}) -> (y : {s : ResGer.PCase => Str;
                                                                         a : ResGer.Agr;
                                                                         isPron : Prelude.Bool;
                                                                         lock_NP : {}}) -> {s : ResGer.PCase => Str;
                                                                                            a : ResGer.Agr;
                                                                                            isPron : Prelude.Bool;
                                                                                            lock_NP : {}}
                     = 0 ;
                mkNP : (c : {lock_Conj : {}; n : ParamX.Number; s1 : Str;
                             s2 : Str}) -> (xy : {a : ResGer.Agr; lock_ListNP : {};
                                                  s1 : ResGer.PCase => Str;
                                                  s2 : ResGer.PCase => Str}) -> {s : ResGer.PCase => Str;
                                                                                 a : ResGer.Agr;
                                                                                 isPron : Prelude.Bool;
                                                                                 lock_NP : {}}
                     = 0 ;
                mkNP : (q : {s : Prelude.Bool => ParamX.Number => ResGer.Gender => ResGer.PCase => Str;
                             a : ResGer.Adjf; isSg : {}; lock_Quant : {};
                             sp : ParamX.Number => ResGer.Gender => ResGer.PCase => Str}) -> (n : {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                                                                                   g : ResGer.Gender;
                                                                                                   lock_CN : {}}) -> {s : ResGer.PCase => Str;
                                                                                                                      a : ResGer.Agr;
                                                                                                                      isPron : Prelude.Bool;
                                                                                                                      lock_NP : {}}
                     = 0 ;
                mkNP : (q : {s : Prelude.Bool => ParamX.Number => ResGer.Gender => ResGer.PCase => Str;
                             a : ResGer.Adjf; isPl : {}; lock_Quant : {};
                             sp : ParamX.Number => ResGer.Gender => ResGer.PCase => Str}) -> (n : {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                                                                                   g : ResGer.Gender;
                                                                                                   lock_CN : {}}) -> {s : ResGer.PCase => Str;
                                                                                                                      a : ResGer.Agr;
                                                                                                                      isPron : Prelude.Bool;
                                                                                                                      lock_NP : {}}
                     = 0 ;
              } ;
  oper mkNum = overload {
                 mkNum : (s : Str) -> {s : ResGer.Gender => ResGer.Case => Str;
                                       isNum : Prelude.Bool; lock_Num : {}; n : ParamX.Number}
                       = 0 ;
                 mkNum : (d : {s : ResGer.CardOrd => Str; lock_Numeral : {};
                               n : ParamX.Number}) -> {s : ResGer.Gender => ResGer.Case => Str;
                                                       isNum : Prelude.Bool; lock_Num : {};
                                                       n : ParamX.Number}
                       = 0 ;
                 mkNum : (d : {s : ResGer.CardOrd => Str; lock_Digits : {};
                               n : ParamX.Number}) -> {s : ResGer.Gender => ResGer.Case => Str;
                                                       isNum : Prelude.Bool; lock_Num : {};
                                                       n : ParamX.Number}
                       = 0 ;
                 mkNum : (d : {s : ResGer.DForm => ResGer.CardOrd => Str;
                               lock_Digit : {}}) -> {s : ResGer.Gender => ResGer.Case => Str;
                                                     isNum : Prelude.Bool; lock_Num : {};
                                                     n : ParamX.Number}
                       = 0 ;
                 mkNum : {s : ResGer.Gender => ResGer.Case => Str; lock_Card : {};
                          n : ParamX.Number} -> {s : ResGer.Gender => ResGer.Case => Str;
                                                 isNum : Prelude.Bool; lock_Num : {};
                                                 n : ParamX.Number}
                       = 0 ;
                 mkNum : (a : {s : Str;
                               lock_AdN : {}}) -> (c : {s : ResGer.Gender => ResGer.Case => Str;
                                                        lock_Card : {};
                                                        n : ParamX.Number}) -> {s : ResGer.Gender => ResGer.Case => Str;
                                                                                isNum : Prelude.Bool;
                                                                                lock_Num : {};
                                                                                n : ParamX.Number}
                       = 0 ;
               } ;
  oper mkNumeral = overload {
                     mkNumeral : (n : {d : {s : ResGer.DForm => ResGer.CardOrd => Str;
                                            lock_Digit : {}};
                                       isOne : Predef.PBool;
                                       n : {s : ResGer.DForm => ResGer.CardOrd => Str;
                                            lock_Sub10 : {};
                                            n : ParamX.Number}}) -> {s : ResGer.CardOrd => Str;
                                                                     lock_Numeral : {};
                                                                     n : ParamX.Number}
                               = 0 ;
                     mkNumeral : (n : {s : ResGer.CardOrd => Str; lock_Sub100 : {};
                                       n : ParamX.Number}) -> {s : ResGer.CardOrd => Str;
                                                               lock_Numeral : {}; n : ParamX.Number}
                               = 0 ;
                     mkNumeral : (n : {s : ResGer.CardOrd => Str; lock_Sub1000 : {};
                                       n : ParamX.Number}) -> {s : ResGer.CardOrd => Str;
                                                               lock_Numeral : {}; n : ParamX.Number}
                               = 0 ;
                     mkNumeral : (m : {s : ResGer.CardOrd => Str; lock_Sub1000 : {};
                                       n : ParamX.Number}) -> (n : {s : ResGer.CardOrd => Str;
                                                                    lock_Sub1000 : {};
                                                                    n : ParamX.Number}) -> {s : ResGer.CardOrd => Str;
                                                                                            lock_Numeral : {};
                                                                                            n : ParamX.Number}
                               = 0 ;
                     mkNumeral : Str -> {s : ResGer.CardOrd => Str; lock_Numeral : {};
                                         n : ParamX.Number}
                               = 0 ;
                   } ;
  oper mkOrd = overload {
                 mkOrd : {s : ResGer.CardOrd => Str; lock_Numeral : {};
                          n : ParamX.Number} -> {s : ResGer.AForm => Str; lock_Ord : {}}
                       = 0 ;
                 mkOrd : {s : ResGer.CardOrd => Str; lock_Digits : {};
                          n : ParamX.Number} -> {s : ResGer.AForm => Str; lock_Ord : {}}
                       = 0 ;
                 mkOrd : (d : {s : ResGer.DForm => ResGer.CardOrd => Str;
                               lock_Digit : {}}) -> {s : ResGer.AForm => Str; lock_Ord : {}}
                       = 0 ;
                 mkOrd : {s : ParamX.Degree => ResGer.AForm => Str;
                          lock_A : {}} -> {s : ResGer.AForm => Str; lock_Ord : {}}
                       = 0 ;
               } ;
  oper mkPConj : {lock_Conj : {}; n : ParamX.Number; s1 : Str;
                  s2 : Str} -> {s : Str; lock_PConj : {}} ;
  oper mkPhr = overload {
                 mkPhr : {s : Str; lock_PConj : {}} -> {s : Str;
                                                        lock_Utt : {}} -> {s : Str;
                                                                           lock_Voc : {}} -> {s : Str;
                                                                                              lock_Phr : {}}
                       = 0 ;
                 mkPhr : (u : {s : Str; lock_Utt : {}}) -> (v : {s : Str;
                                                                 lock_Voc : {}}) -> {s : Str;
                                                                                     lock_Phr : {}}
                       = 0 ;
                 mkPhr : (u : {s : Str; lock_PConj : {}}) -> (v : {s : Str;
                                                                   lock_Utt : {}}) -> {s : Str;
                                                                                       lock_Phr : {}}
                       = 0 ;
                 mkPhr : (u : {s : Str; lock_Utt : {}}) -> {s : Str; lock_Phr : {}}
                       = 0 ;
                 mkPhr : (s : {s : ResGer.Order => Str; lock_S : {}}) -> {s : Str;
                                                                          lock_Phr : {}}
                       = 0 ;
                 mkPhr : (s : {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                               lock_Cl : {}}) -> {s : Str; lock_Phr : {}}
                       = 0 ;
                 mkPhr : (s : {s : ParamX.QForm => Str; lock_QS : {}}) -> {s : Str;
                                                                           lock_Phr : {}}
                       = 0 ;
                 mkPhr : (s : {s : ParamX.Polarity => ParamX.ImpForm => Str;
                               lock_Imp : {}}) -> {s : Str; lock_Phr : {}}
                       = 0 ;
               } ;
  oper mkQCl = overload {
                 mkQCl : {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                          lock_Cl : {}} -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ParamX.QForm => Str;
                                            lock_QCl : {}}
                       = 0 ;
                 mkQCl : {s : ResGer.Case => Str; lock_IP : {};
                          n : ParamX.Number} -> {s : {s : ResGer.VForm => Str;
                                                      aux : ResGer.VAux; prefix : Str;
                                                      vtype : ResGer.VType};
                                                 a1 : ParamX.Polarity => Str; a2 : Str; ext : Str;
                                                 inf : Str; isAux : Prelude.Bool; lock_VP : {};
                                                 n0 : ResGer.Agr => Str;
                                                 n2 : ResGer.Agr => Str} -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ParamX.QForm => Str;
                                                                             lock_QCl : {}}
                       = 0 ;
                 mkQCl : (s : {s : ResGer.Case => Str; lock_IP : {};
                               n : ParamX.Number}) -> (v : {s : ResGer.VForm => Str;
                                                            aux : ResGer.VAux; lock_V : {};
                                                            prefix : Str;
                                                            vtype : ResGer.VType}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ParamX.QForm => Str;
                                                                                       lock_QCl : {}}
                       = 0 ;
                 mkQCl : (s : {s : ResGer.Case => Str; lock_IP : {};
                               n : ParamX.Number}) -> (v : {s : ResGer.VForm => Str;
                                                            aux : ResGer.VAux;
                                                            c2 : {s : Str; c : ResGer.PCase};
                                                            lock_V2 : {}; prefix : Str;
                                                            vtype : ResGer.VType}) -> (o : {s : ResGer.PCase => Str;
                                                                                            a : ResGer.Agr;
                                                                                            isPron : Prelude.Bool;
                                                                                            lock_NP : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ParamX.QForm => Str;
                                                                                                               lock_QCl : {}}
                       = 0 ;
                 mkQCl : (s : {s : ResGer.Case => Str; lock_IP : {};
                               n : ParamX.Number}) -> (v : {s : ResGer.VForm => Str;
                                                            aux : ResGer.VAux;
                                                            c2 : {s : Str; c : ResGer.PCase};
                                                            c3 : {s : Str; c : ResGer.PCase};
                                                            lock_V3 : {}; prefix : Str;
                                                            vtype : ResGer.VType}) -> (o : {s : ResGer.PCase => Str;
                                                                                            a : ResGer.Agr;
                                                                                            isPron : Prelude.Bool;
                                                                                            lock_NP : {}}) -> (i : {s : ResGer.PCase => Str;
                                                                                                                    a : ResGer.Agr;
                                                                                                                    isPron : Prelude.Bool;
                                                                                                                    lock_NP : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ParamX.QForm => Str;
                                                                                                                                       lock_QCl : {}}
                       = 0 ;
                 mkQCl : (s : {s : ResGer.Case => Str; lock_IP : {};
                               n : ParamX.Number}) -> (v : {s : ResGer.VForm => Str;
                                                            aux : ResGer.VAux; isAux : Prelude.Bool;
                                                            lock_VV : {}; prefix : Str;
                                                            vtype : ResGer.VType}) -> (vp : {s : {s : ResGer.VForm => Str;
                                                                                                  aux : ResGer.VAux;
                                                                                                  prefix : Str;
                                                                                                  vtype : ResGer.VType};
                                                                                             a1 : ParamX.Polarity => Str;
                                                                                             a2 : Str;
                                                                                             ext : Str;
                                                                                             inf : Str;
                                                                                             isAux : Prelude.Bool;
                                                                                             lock_VP : {};
                                                                                             n0 : ResGer.Agr => Str;
                                                                                             n2 : ResGer.Agr => Str}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ParamX.QForm => Str;
                                                                                                                          lock_QCl : {}}
                       = 0 ;
                 mkQCl : (s : {s : ResGer.Case => Str; lock_IP : {};
                               n : ParamX.Number}) -> (v : {s : ResGer.VForm => Str;
                                                            aux : ResGer.VAux; lock_VS : {};
                                                            prefix : Str;
                                                            vtype : ResGer.VType}) -> (p : {s : ResGer.Order => Str;
                                                                                            lock_S : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ParamX.QForm => Str;
                                                                                                              lock_QCl : {}}
                       = 0 ;
                 mkQCl : (s : {s : ResGer.Case => Str; lock_IP : {};
                               n : ParamX.Number}) -> (v : {s : ResGer.VForm => Str;
                                                            aux : ResGer.VAux; lock_VQ : {};
                                                            prefix : Str;
                                                            vtype : ResGer.VType}) -> (q : {s : ParamX.QForm => Str;
                                                                                            lock_QS : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ParamX.QForm => Str;
                                                                                                               lock_QCl : {}}
                       = 0 ;
                 mkQCl : (s : {s : ResGer.Case => Str; lock_IP : {};
                               n : ParamX.Number}) -> (v : {s : ResGer.VForm => Str;
                                                            aux : ResGer.VAux; lock_VA : {};
                                                            prefix : Str;
                                                            vtype : ResGer.VType}) -> (q : {s : ParamX.Degree => ResGer.AForm => Str;
                                                                                            lock_A : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ParamX.QForm => Str;
                                                                                                              lock_QCl : {}}
                       = 0 ;
                 mkQCl : (s : {s : ResGer.Case => Str; lock_IP : {};
                               n : ParamX.Number}) -> (v : {s : ResGer.VForm => Str;
                                                            aux : ResGer.VAux; lock_VA : {};
                                                            prefix : Str;
                                                            vtype : ResGer.VType}) -> (q : {s : ResGer.AForm => Str;
                                                                                            isPre : Prelude.Bool;
                                                                                            lock_AP : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ParamX.QForm => Str;
                                                                                                               lock_QCl : {}}
                       = 0 ;
                 mkQCl : (s : {s : ResGer.Case => Str; lock_IP : {};
                               n : ParamX.Number}) -> (v : {s : ResGer.VForm => Str;
                                                            aux : ResGer.VAux;
                                                            c2 : {s : Str; c : ResGer.PCase};
                                                            lock_V2A : {}; prefix : Str;
                                                            vtype : ResGer.VType}) -> (n : {s : ResGer.PCase => Str;
                                                                                            a : ResGer.Agr;
                                                                                            isPron : Prelude.Bool;
                                                                                            lock_NP : {}}) -> (q : {s : ParamX.Degree => ResGer.AForm => Str;
                                                                                                                    lock_A : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ParamX.QForm => Str;
                                                                                                                                      lock_QCl : {}}
                       = 0 ;
                 mkQCl : (s : {s : ResGer.Case => Str; lock_IP : {};
                               n : ParamX.Number}) -> (v : {s : ResGer.VForm => Str;
                                                            aux : ResGer.VAux;
                                                            c2 : {s : Str; c : ResGer.PCase};
                                                            lock_V2A : {}; prefix : Str;
                                                            vtype : ResGer.VType}) -> (n : {s : ResGer.PCase => Str;
                                                                                            a : ResGer.Agr;
                                                                                            isPron : Prelude.Bool;
                                                                                            lock_NP : {}}) -> (q : {s : ResGer.AForm => Str;
                                                                                                                    isPre : Prelude.Bool;
                                                                                                                    lock_AP : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ParamX.QForm => Str;
                                                                                                                                       lock_QCl : {}}
                       = 0 ;
                 mkQCl : (s : {s : ResGer.Case => Str; lock_IP : {};
                               n : ParamX.Number}) -> (v : {s : ResGer.VForm => Str;
                                                            aux : ResGer.VAux;
                                                            c2 : {s : Str; c : ResGer.PCase};
                                                            lock_V2S : {}; prefix : Str;
                                                            vtype : ResGer.VType}) -> (n : {s : ResGer.PCase => Str;
                                                                                            a : ResGer.Agr;
                                                                                            isPron : Prelude.Bool;
                                                                                            lock_NP : {}}) -> (q : {s : ResGer.Order => Str;
                                                                                                                    lock_S : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ParamX.QForm => Str;
                                                                                                                                      lock_QCl : {}}
                       = 0 ;
                 mkQCl : (s : {s : ResGer.Case => Str; lock_IP : {};
                               n : ParamX.Number}) -> (v : {s : ResGer.VForm => Str;
                                                            aux : ResGer.VAux;
                                                            c2 : {s : Str; c : ResGer.PCase};
                                                            lock_V2Q : {}; prefix : Str;
                                                            vtype : ResGer.VType}) -> (n : {s : ResGer.PCase => Str;
                                                                                            a : ResGer.Agr;
                                                                                            isPron : Prelude.Bool;
                                                                                            lock_NP : {}}) -> (q : {s : ParamX.QForm => Str;
                                                                                                                    lock_QS : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ParamX.QForm => Str;
                                                                                                                                       lock_QCl : {}}
                       = 0 ;
                 mkQCl : (s : {s : ResGer.Case => Str; lock_IP : {};
                               n : ParamX.Number}) -> (v : {s : ResGer.VForm => Str;
                                                            aux : ResGer.VAux;
                                                            c2 : {s : Str; c : ResGer.PCase};
                                                            isAux : Prelude.Bool; lock_V2V : {};
                                                            prefix : Str;
                                                            vtype : ResGer.VType}) -> (n : {s : ResGer.PCase => Str;
                                                                                            a : ResGer.Agr;
                                                                                            isPron : Prelude.Bool;
                                                                                            lock_NP : {}}) -> (q : {s : {s : ResGer.VForm => Str;
                                                                                                                         aux : ResGer.VAux;
                                                                                                                         prefix : Str;
                                                                                                                         vtype : ResGer.VType};
                                                                                                                    a1 : ParamX.Polarity => Str;
                                                                                                                    a2 : Str;
                                                                                                                    ext : Str;
                                                                                                                    inf : Str;
                                                                                                                    isAux : Prelude.Bool;
                                                                                                                    lock_VP : {};
                                                                                                                    n0 : ResGer.Agr => Str;
                                                                                                                    n2 : ResGer.Agr => Str}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ParamX.QForm => Str;
                                                                                                                                                 lock_QCl : {}}
                       = 0 ;
                 mkQCl : (x : {s : ResGer.Case => Str; lock_IP : {};
                               n : ParamX.Number}) -> (y : {s : ParamX.Degree => ResGer.AForm => Str;
                                                            lock_A : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ParamX.QForm => Str;
                                                                              lock_QCl : {}}
                       = 0 ;
                 mkQCl : (x : {s : ResGer.Case => Str; lock_IP : {};
                               n : ParamX.Number}) -> (y : {s : ParamX.Degree => ResGer.AForm => Str;
                                                            lock_A : {}}) -> (z : {s : ResGer.PCase => Str;
                                                                                   a : ResGer.Agr;
                                                                                   isPron : Prelude.Bool;
                                                                                   lock_NP : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ParamX.QForm => Str;
                                                                                                      lock_QCl : {}}
                       = 0 ;
                 mkQCl : (x : {s : ResGer.Case => Str; lock_IP : {};
                               n : ParamX.Number}) -> (y : {s : ParamX.Degree => ResGer.AForm => Str;
                                                            c2 : {s : Str; c : ResGer.PCase};
                                                            lock_A2 : {}}) -> (z : {s : ResGer.PCase => Str;
                                                                                    a : ResGer.Agr;
                                                                                    isPron : Prelude.Bool;
                                                                                    lock_NP : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ParamX.QForm => Str;
                                                                                                       lock_QCl : {}}
                       = 0 ;
                 mkQCl : (x : {s : ResGer.Case => Str; lock_IP : {};
                               n : ParamX.Number}) -> (y : {s : ResGer.AForm => Str;
                                                            isPre : Prelude.Bool;
                                                            lock_AP : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ParamX.QForm => Str;
                                                                               lock_QCl : {}}
                       = 0 ;
                 mkQCl : (x : {s : ResGer.Case => Str; lock_IP : {};
                               n : ParamX.Number}) -> (y : {s : ResGer.PCase => Str;
                                                            a : ResGer.Agr; isPron : Prelude.Bool;
                                                            lock_NP : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ParamX.QForm => Str;
                                                                               lock_QCl : {}}
                       = 0 ;
                 mkQCl : (x : {s : ResGer.Case => Str; lock_IP : {};
                               n : ParamX.Number}) -> (y : {s : ParamX.Number => ResGer.Case => Str;
                                                            g : ResGer.Gender;
                                                            lock_N : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ParamX.QForm => Str;
                                                                              lock_QCl : {}}
                       = 0 ;
                 mkQCl : (x : {s : ResGer.Case => Str; lock_IP : {};
                               n : ParamX.Number}) -> (y : {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                                            g : ResGer.Gender;
                                                            lock_CN : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ParamX.QForm => Str;
                                                                               lock_QCl : {}}
                       = 0 ;
                 mkQCl : (x : {s : ResGer.Case => Str; lock_IP : {};
                               n : ParamX.Number}) -> (y : {s : Str;
                                                            lock_Adv : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ParamX.QForm => Str;
                                                                                lock_QCl : {}}
                       = 0 ;
                 mkQCl : (ip : {s : ResGer.Case => Str; lock_IP : {};
                                n : ParamX.Number}) -> (np : {s : ResGer.PCase => Str;
                                                              a : ResGer.Agr; isPron : Prelude.Bool;
                                                              lock_NP : {}}) -> (v : {s : ResGer.VForm => Str;
                                                                                      aux : ResGer.VAux;
                                                                                      c2 : {s : Str;
                                                                                            c : ResGer.PCase};
                                                                                      lock_V2 : {};
                                                                                      prefix : Str;
                                                                                      vtype : ResGer.VType}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ParamX.QForm => Str;
                                                                                                                 lock_QCl : {}}
                       = 0 ;
                 mkQCl : {s : ResGer.Case => Str; lock_IP : {};
                          n : ParamX.Number} -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                 c2 : {s : Str; c : ResGer.PCase};
                                                 lock_ClSlash : {}} -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ParamX.QForm => Str;
                                                                        lock_QCl : {}}
                       = 0 ;
                 mkQCl : {s : Str;
                          lock_IAdv : {}} -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                              lock_Cl : {}} -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ParamX.QForm => Str;
                                                                lock_QCl : {}}
                       = 0 ;
                 mkQCl : (p : {s : Str; c : ResGer.PCase;
                               lock_Prep : {}}) -> (ip : {s : ResGer.Case => Str; lock_IP : {};
                                                          n : ParamX.Number}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                                                  lock_Cl : {}} -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ParamX.QForm => Str;
                                                                                                    lock_QCl : {}}
                       = 0 ;
                 mkQCl : (a : {s : Str;
                               lock_IAdv : {}}) -> {s : ResGer.PCase => Str; a : ResGer.Agr;
                                                    isPron : Prelude.Bool;
                                                    lock_NP : {}} -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ParamX.QForm => Str;
                                                                      lock_QCl : {}}
                       = 0 ;
                 mkQCl : (a : {s : ResGer.Agr => Str;
                               lock_IComp : {}}) -> {s : ResGer.PCase => Str; a : ResGer.Agr;
                                                     isPron : Prelude.Bool;
                                                     lock_NP : {}} -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ParamX.QForm => Str;
                                                                       lock_QCl : {}}
                       = 0 ;
                 mkQCl : {s : ResGer.Case => Str; lock_IP : {};
                          n : ParamX.Number} -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ParamX.QForm => Str;
                                                 lock_QCl : {}}
                       = 0 ;
               } ;
  oper mkQS = overload {
                mkQS : {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ParamX.QForm => Str;
                        lock_QCl : {}} -> {s : ParamX.QForm => Str; lock_QS : {}}
                     = 0 ;
                mkQS : (t : {s : Str; lock_Tense : {}; m : ResGer.Mood;
                             t : ParamX.Tense}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ParamX.QForm => Str;
                                                    lock_QCl : {}} -> {s : ParamX.QForm => Str;
                                                                       lock_QS : {}}
                     = 0 ;
                mkQS : (a : {s : Str; a : ParamX.Anteriority;
                             lock_Ant : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ParamX.QForm => Str;
                                                 lock_QCl : {}} -> {s : ParamX.QForm => Str;
                                                                    lock_QS : {}}
                     = 0 ;
                mkQS : (p : {s : Str; lock_Pol : {};
                             p : ParamX.Polarity}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ParamX.QForm => Str;
                                                       lock_QCl : {}} -> {s : ParamX.QForm => Str;
                                                                          lock_QS : {}}
                     = 0 ;
                mkQS : (t : {s : Str; lock_Tense : {}; m : ResGer.Mood;
                             t : ParamX.Tense}) -> (a : {s : Str; a : ParamX.Anteriority;
                                                         lock_Ant : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ParamX.QForm => Str;
                                                                             lock_QCl : {}} -> {s : ParamX.QForm => Str;
                                                                                                lock_QS : {}}
                     = 0 ;
                mkQS : (t : {s : Str; lock_Tense : {}; m : ResGer.Mood;
                             t : ParamX.Tense}) -> (p : {s : Str; lock_Pol : {};
                                                         p : ParamX.Polarity}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ParamX.QForm => Str;
                                                                                   lock_QCl : {}} -> {s : ParamX.QForm => Str;
                                                                                                      lock_QS : {}}
                     = 0 ;
                mkQS : (a : {s : Str; a : ParamX.Anteriority;
                             lock_Ant : {}}) -> (p : {s : Str; lock_Pol : {};
                                                      p : ParamX.Polarity}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ParamX.QForm => Str;
                                                                                lock_QCl : {}} -> {s : ParamX.QForm => Str;
                                                                                                   lock_QS : {}}
                     = 0 ;
                mkQS : {s : Str; lock_Tense : {}; m : ResGer.Mood;
                        t : ParamX.Tense} -> {s : Str; a : ParamX.Anteriority;
                                              lock_Ant : {}} -> {s : Str; lock_Pol : {};
                                                                 p : ParamX.Polarity} -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ParamX.QForm => Str;
                                                                                          lock_QCl : {}} -> {s : ParamX.QForm => Str;
                                                                                                             lock_QS : {}}
                     = 0 ;
                mkQS : (x : {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                             lock_Cl : {}}) -> {s : ParamX.QForm => Str; lock_QS : {}}
                     = 0 ;
              } ;
  oper mkQuant = overload {
                   mkQuant : {s : ResGer.NPForm => Str; a : ResGer.Agr;
                              lock_Pron : {}} -> {s : Prelude.Bool => ParamX.Number => ResGer.Gender => ResGer.PCase => Str;
                                                  a : ResGer.Adjf; lock_Quant : {};
                                                  sp : ParamX.Number => ResGer.Gender => ResGer.PCase => Str}
                           = 0 ;
                 } ;
  oper mkQuantPl : {s : Prelude.Bool => ParamX.Number => ResGer.Gender => ResGer.PCase => Str;
                    a : ResGer.Adjf; lock_Quant : {};
                    sp : ParamX.Number => ResGer.Gender => ResGer.PCase => Str} -> {s : Prelude.Bool => ParamX.Number => ResGer.Gender => ResGer.PCase => Str;
                                                                                    a : ResGer.Adjf;
                                                                                    isPl : {};
                                                                                    lock_Quant : {};
                                                                                    sp : ParamX.Number => ResGer.Gender => ResGer.PCase => Str} ;
  oper mkQuantSg : {s : Prelude.Bool => ParamX.Number => ResGer.Gender => ResGer.PCase => Str;
                    a : ResGer.Adjf; lock_Quant : {};
                    sp : ParamX.Number => ResGer.Gender => ResGer.PCase => Str} -> {s : Prelude.Bool => ParamX.Number => ResGer.Gender => ResGer.PCase => Str;
                                                                                    a : ResGer.Adjf;
                                                                                    isSg : {};
                                                                                    lock_Quant : {};
                                                                                    sp : ParamX.Number => ResGer.Gender => ResGer.PCase => Str} ;
  oper mkRCl = overload {
                 mkRCl : {s : ResGer.GenNum => ResGer.Case => Str; a : ResGer.RAgr;
                          lock_RP : {}} -> {s : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                                                 prefix : Str; vtype : ResGer.VType};
                                            a1 : ParamX.Polarity => Str; a2 : Str; ext : Str;
                                            inf : Str; isAux : Prelude.Bool; lock_VP : {};
                                            n0 : ResGer.Agr => Str;
                                            n2 : ResGer.Agr => Str} -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.GenNum => Str;
                                                                        c : ResGer.Case;
                                                                        lock_RCl : {}}
                       = 0 ;
                 mkRCl : (s : {s : ResGer.GenNum => ResGer.Case => Str;
                               a : ResGer.RAgr; lock_RP : {}}) -> (v : {s : ResGer.VForm => Str;
                                                                        aux : ResGer.VAux;
                                                                        lock_V : {}; prefix : Str;
                                                                        vtype : ResGer.VType}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.GenNum => Str;
                                                                                                   c : ResGer.Case;
                                                                                                   lock_RCl : {}}
                       = 0 ;
                 mkRCl : (s : {s : ResGer.GenNum => ResGer.Case => Str;
                               a : ResGer.RAgr; lock_RP : {}}) -> (v : {s : ResGer.VForm => Str;
                                                                        aux : ResGer.VAux;
                                                                        c2 : {s : Str;
                                                                              c : ResGer.PCase};
                                                                        lock_V2 : {}; prefix : Str;
                                                                        vtype : ResGer.VType}) -> (o : {s : ResGer.PCase => Str;
                                                                                                        a : ResGer.Agr;
                                                                                                        isPron : Prelude.Bool;
                                                                                                        lock_NP : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.GenNum => Str;
                                                                                                                           c : ResGer.Case;
                                                                                                                           lock_RCl : {}}
                       = 0 ;
                 mkRCl : (s : {s : ResGer.GenNum => ResGer.Case => Str;
                               a : ResGer.RAgr; lock_RP : {}}) -> (v : {s : ResGer.VForm => Str;
                                                                        aux : ResGer.VAux;
                                                                        c2 : {s : Str;
                                                                              c : ResGer.PCase};
                                                                        c3 : {s : Str;
                                                                              c : ResGer.PCase};
                                                                        lock_V3 : {}; prefix : Str;
                                                                        vtype : ResGer.VType}) -> (o : {s : ResGer.PCase => Str;
                                                                                                        a : ResGer.Agr;
                                                                                                        isPron : Prelude.Bool;
                                                                                                        lock_NP : {}}) -> (i : {s : ResGer.PCase => Str;
                                                                                                                                a : ResGer.Agr;
                                                                                                                                isPron : Prelude.Bool;
                                                                                                                                lock_NP : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.GenNum => Str;
                                                                                                                                                   c : ResGer.Case;
                                                                                                                                                   lock_RCl : {}}
                       = 0 ;
                 mkRCl : (s : {s : ResGer.GenNum => ResGer.Case => Str;
                               a : ResGer.RAgr; lock_RP : {}}) -> (v : {s : ResGer.VForm => Str;
                                                                        aux : ResGer.VAux;
                                                                        isAux : Prelude.Bool;
                                                                        lock_VV : {}; prefix : Str;
                                                                        vtype : ResGer.VType}) -> (vp : {s : {s : ResGer.VForm => Str;
                                                                                                              aux : ResGer.VAux;
                                                                                                              prefix : Str;
                                                                                                              vtype : ResGer.VType};
                                                                                                         a1 : ParamX.Polarity => Str;
                                                                                                         a2 : Str;
                                                                                                         ext : Str;
                                                                                                         inf : Str;
                                                                                                         isAux : Prelude.Bool;
                                                                                                         lock_VP : {};
                                                                                                         n0 : ResGer.Agr => Str;
                                                                                                         n2 : ResGer.Agr => Str}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.GenNum => Str;
                                                                                                                                      c : ResGer.Case;
                                                                                                                                      lock_RCl : {}}
                       = 0 ;
                 mkRCl : (s : {s : ResGer.GenNum => ResGer.Case => Str;
                               a : ResGer.RAgr; lock_RP : {}}) -> (v : {s : ResGer.VForm => Str;
                                                                        aux : ResGer.VAux;
                                                                        lock_VS : {}; prefix : Str;
                                                                        vtype : ResGer.VType}) -> (p : {s : ResGer.Order => Str;
                                                                                                        lock_S : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.GenNum => Str;
                                                                                                                          c : ResGer.Case;
                                                                                                                          lock_RCl : {}}
                       = 0 ;
                 mkRCl : (s : {s : ResGer.GenNum => ResGer.Case => Str;
                               a : ResGer.RAgr; lock_RP : {}}) -> (v : {s : ResGer.VForm => Str;
                                                                        aux : ResGer.VAux;
                                                                        lock_VQ : {}; prefix : Str;
                                                                        vtype : ResGer.VType}) -> (q : {s : ParamX.QForm => Str;
                                                                                                        lock_QS : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.GenNum => Str;
                                                                                                                           c : ResGer.Case;
                                                                                                                           lock_RCl : {}}
                       = 0 ;
                 mkRCl : (s : {s : ResGer.GenNum => ResGer.Case => Str;
                               a : ResGer.RAgr; lock_RP : {}}) -> (v : {s : ResGer.VForm => Str;
                                                                        aux : ResGer.VAux;
                                                                        lock_VA : {}; prefix : Str;
                                                                        vtype : ResGer.VType}) -> (q : {s : ParamX.Degree => ResGer.AForm => Str;
                                                                                                        lock_A : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.GenNum => Str;
                                                                                                                          c : ResGer.Case;
                                                                                                                          lock_RCl : {}}
                       = 0 ;
                 mkRCl : (s : {s : ResGer.GenNum => ResGer.Case => Str;
                               a : ResGer.RAgr; lock_RP : {}}) -> (v : {s : ResGer.VForm => Str;
                                                                        aux : ResGer.VAux;
                                                                        lock_VA : {}; prefix : Str;
                                                                        vtype : ResGer.VType}) -> (q : {s : ResGer.AForm => Str;
                                                                                                        isPre : Prelude.Bool;
                                                                                                        lock_AP : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.GenNum => Str;
                                                                                                                           c : ResGer.Case;
                                                                                                                           lock_RCl : {}}
                       = 0 ;
                 mkRCl : (s : {s : ResGer.GenNum => ResGer.Case => Str;
                               a : ResGer.RAgr; lock_RP : {}}) -> (v : {s : ResGer.VForm => Str;
                                                                        aux : ResGer.VAux;
                                                                        c2 : {s : Str;
                                                                              c : ResGer.PCase};
                                                                        lock_V2A : {}; prefix : Str;
                                                                        vtype : ResGer.VType}) -> (n : {s : ResGer.PCase => Str;
                                                                                                        a : ResGer.Agr;
                                                                                                        isPron : Prelude.Bool;
                                                                                                        lock_NP : {}}) -> (q : {s : ParamX.Degree => ResGer.AForm => Str;
                                                                                                                                lock_A : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.GenNum => Str;
                                                                                                                                                  c : ResGer.Case;
                                                                                                                                                  lock_RCl : {}}
                       = 0 ;
                 mkRCl : (s : {s : ResGer.GenNum => ResGer.Case => Str;
                               a : ResGer.RAgr; lock_RP : {}}) -> (v : {s : ResGer.VForm => Str;
                                                                        aux : ResGer.VAux;
                                                                        c2 : {s : Str;
                                                                              c : ResGer.PCase};
                                                                        lock_V2A : {}; prefix : Str;
                                                                        vtype : ResGer.VType}) -> (n : {s : ResGer.PCase => Str;
                                                                                                        a : ResGer.Agr;
                                                                                                        isPron : Prelude.Bool;
                                                                                                        lock_NP : {}}) -> (q : {s : ResGer.AForm => Str;
                                                                                                                                isPre : Prelude.Bool;
                                                                                                                                lock_AP : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.GenNum => Str;
                                                                                                                                                   c : ResGer.Case;
                                                                                                                                                   lock_RCl : {}}
                       = 0 ;
                 mkRCl : (s : {s : ResGer.GenNum => ResGer.Case => Str;
                               a : ResGer.RAgr; lock_RP : {}}) -> (v : {s : ResGer.VForm => Str;
                                                                        aux : ResGer.VAux;
                                                                        c2 : {s : Str;
                                                                              c : ResGer.PCase};
                                                                        lock_V2S : {}; prefix : Str;
                                                                        vtype : ResGer.VType}) -> (n : {s : ResGer.PCase => Str;
                                                                                                        a : ResGer.Agr;
                                                                                                        isPron : Prelude.Bool;
                                                                                                        lock_NP : {}}) -> (q : {s : ResGer.Order => Str;
                                                                                                                                lock_S : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.GenNum => Str;
                                                                                                                                                  c : ResGer.Case;
                                                                                                                                                  lock_RCl : {}}
                       = 0 ;
                 mkRCl : (s : {s : ResGer.GenNum => ResGer.Case => Str;
                               a : ResGer.RAgr; lock_RP : {}}) -> (v : {s : ResGer.VForm => Str;
                                                                        aux : ResGer.VAux;
                                                                        c2 : {s : Str;
                                                                              c : ResGer.PCase};
                                                                        lock_V2Q : {}; prefix : Str;
                                                                        vtype : ResGer.VType}) -> (n : {s : ResGer.PCase => Str;
                                                                                                        a : ResGer.Agr;
                                                                                                        isPron : Prelude.Bool;
                                                                                                        lock_NP : {}}) -> (q : {s : ParamX.QForm => Str;
                                                                                                                                lock_QS : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.GenNum => Str;
                                                                                                                                                   c : ResGer.Case;
                                                                                                                                                   lock_RCl : {}}
                       = 0 ;
                 mkRCl : (s : {s : ResGer.GenNum => ResGer.Case => Str;
                               a : ResGer.RAgr; lock_RP : {}}) -> (v : {s : ResGer.VForm => Str;
                                                                        aux : ResGer.VAux;
                                                                        c2 : {s : Str;
                                                                              c : ResGer.PCase};
                                                                        isAux : Prelude.Bool;
                                                                        lock_V2V : {}; prefix : Str;
                                                                        vtype : ResGer.VType}) -> (n : {s : ResGer.PCase => Str;
                                                                                                        a : ResGer.Agr;
                                                                                                        isPron : Prelude.Bool;
                                                                                                        lock_NP : {}}) -> (q : {s : {s : ResGer.VForm => Str;
                                                                                                                                     aux : ResGer.VAux;
                                                                                                                                     prefix : Str;
                                                                                                                                     vtype : ResGer.VType};
                                                                                                                                a1 : ParamX.Polarity => Str;
                                                                                                                                a2 : Str;
                                                                                                                                ext : Str;
                                                                                                                                inf : Str;
                                                                                                                                isAux : Prelude.Bool;
                                                                                                                                lock_VP : {};
                                                                                                                                n0 : ResGer.Agr => Str;
                                                                                                                                n2 : ResGer.Agr => Str}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.GenNum => Str;
                                                                                                                                                             c : ResGer.Case;
                                                                                                                                                             lock_RCl : {}}
                       = 0 ;
                 mkRCl : (x : {s : ResGer.GenNum => ResGer.Case => Str;
                               a : ResGer.RAgr;
                               lock_RP : {}}) -> (y : {s : ParamX.Degree => ResGer.AForm => Str;
                                                       lock_A : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.GenNum => Str;
                                                                         c : ResGer.Case;
                                                                         lock_RCl : {}}
                       = 0 ;
                 mkRCl : (x : {s : ResGer.GenNum => ResGer.Case => Str;
                               a : ResGer.RAgr;
                               lock_RP : {}}) -> (y : {s : ParamX.Degree => ResGer.AForm => Str;
                                                       lock_A : {}}) -> (z : {s : ResGer.PCase => Str;
                                                                              a : ResGer.Agr;
                                                                              isPron : Prelude.Bool;
                                                                              lock_NP : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.GenNum => Str;
                                                                                                 c : ResGer.Case;
                                                                                                 lock_RCl : {}}
                       = 0 ;
                 mkRCl : (x : {s : ResGer.GenNum => ResGer.Case => Str;
                               a : ResGer.RAgr;
                               lock_RP : {}}) -> (y : {s : ParamX.Degree => ResGer.AForm => Str;
                                                       c2 : {s : Str; c : ResGer.PCase};
                                                       lock_A2 : {}}) -> (z : {s : ResGer.PCase => Str;
                                                                               a : ResGer.Agr;
                                                                               isPron : Prelude.Bool;
                                                                               lock_NP : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.GenNum => Str;
                                                                                                  c : ResGer.Case;
                                                                                                  lock_RCl : {}}
                       = 0 ;
                 mkRCl : (x : {s : ResGer.GenNum => ResGer.Case => Str;
                               a : ResGer.RAgr; lock_RP : {}}) -> (y : {s : ResGer.AForm => Str;
                                                                        isPre : Prelude.Bool;
                                                                        lock_AP : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.GenNum => Str;
                                                                                           c : ResGer.Case;
                                                                                           lock_RCl : {}}
                       = 0 ;
                 mkRCl : (x : {s : ResGer.GenNum => ResGer.Case => Str;
                               a : ResGer.RAgr; lock_RP : {}}) -> (y : {s : ResGer.PCase => Str;
                                                                        a : ResGer.Agr;
                                                                        isPron : Prelude.Bool;
                                                                        lock_NP : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.GenNum => Str;
                                                                                           c : ResGer.Case;
                                                                                           lock_RCl : {}}
                       = 0 ;
                 mkRCl : (x : {s : ResGer.GenNum => ResGer.Case => Str;
                               a : ResGer.RAgr;
                               lock_RP : {}}) -> (y : {s : ParamX.Number => ResGer.Case => Str;
                                                       g : ResGer.Gender;
                                                       lock_N : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.GenNum => Str;
                                                                         c : ResGer.Case;
                                                                         lock_RCl : {}}
                       = 0 ;
                 mkRCl : (x : {s : ResGer.GenNum => ResGer.Case => Str;
                               a : ResGer.RAgr;
                               lock_RP : {}}) -> (y : {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                                                       g : ResGer.Gender;
                                                       lock_CN : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.GenNum => Str;
                                                                          c : ResGer.Case;
                                                                          lock_RCl : {}}
                       = 0 ;
                 mkRCl : (x : {s : ResGer.GenNum => ResGer.Case => Str;
                               a : ResGer.RAgr; lock_RP : {}}) -> (y : {s : Str;
                                                                        lock_Adv : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.GenNum => Str;
                                                                                            c : ResGer.Case;
                                                                                            lock_RCl : {}}
                       = 0 ;
                 mkRCl : (ip : {s : ResGer.GenNum => ResGer.Case => Str;
                                a : ResGer.RAgr; lock_RP : {}}) -> (np : {s : ResGer.PCase => Str;
                                                                          a : ResGer.Agr;
                                                                          isPron : Prelude.Bool;
                                                                          lock_NP : {}}) -> (v : {s : ResGer.VForm => Str;
                                                                                                  aux : ResGer.VAux;
                                                                                                  c2 : {s : Str;
                                                                                                        c : ResGer.PCase};
                                                                                                  lock_V2 : {};
                                                                                                  prefix : Str;
                                                                                                  vtype : ResGer.VType}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.GenNum => Str;
                                                                                                                             c : ResGer.Case;
                                                                                                                             lock_RCl : {}}
                       = 0 ;
                 mkRCl : {s : ResGer.GenNum => ResGer.Case => Str; a : ResGer.RAgr;
                          lock_RP : {}} -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                            c2 : {s : Str; c : ResGer.PCase};
                                            lock_ClSlash : {}} -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.GenNum => Str;
                                                                   c : ResGer.Case; lock_RCl : {}}
                       = 0 ;
                 mkRCl : {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                          lock_Cl : {}} -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.GenNum => Str;
                                            c : ResGer.Case; lock_RCl : {}}
                       = 0 ;
               } ;
  oper mkRP : {s : Str; c : ResGer.PCase;
               lock_Prep : {}} -> {s : ResGer.PCase => Str; a : ResGer.Agr;
                                   isPron : Prelude.Bool;
                                   lock_NP : {}} -> {s : ResGer.GenNum => ResGer.Case => Str;
                                                     a : ResGer.RAgr;
                                                     lock_RP : {}} -> {s : ResGer.GenNum => ResGer.Case => Str;
                                                                       a : ResGer.RAgr;
                                                                       lock_RP : {}} ;
  oper mkRS = overload {
                mkRS : {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.GenNum => Str;
                        c : ResGer.Case; lock_RCl : {}} -> {s : ResGer.GenNum => Str;
                                                            c : ResGer.Case; lock_RS : {}}
                     = 0 ;
                mkRS : (t : {s : Str; lock_Tense : {}; m : ResGer.Mood;
                             t : ParamX.Tense}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.GenNum => Str;
                                                    c : ResGer.Case;
                                                    lock_RCl : {}} -> {s : ResGer.GenNum => Str;
                                                                       c : ResGer.Case;
                                                                       lock_RS : {}}
                     = 0 ;
                mkRS : (a : {s : Str; a : ParamX.Anteriority;
                             lock_Ant : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.GenNum => Str;
                                                 c : ResGer.Case;
                                                 lock_RCl : {}} -> {s : ResGer.GenNum => Str;
                                                                    c : ResGer.Case; lock_RS : {}}
                     = 0 ;
                mkRS : (p : {s : Str; lock_Pol : {};
                             p : ParamX.Polarity}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.GenNum => Str;
                                                       c : ResGer.Case;
                                                       lock_RCl : {}} -> {s : ResGer.GenNum => Str;
                                                                          c : ResGer.Case;
                                                                          lock_RS : {}}
                     = 0 ;
                mkRS : (t : {s : Str; lock_Tense : {}; m : ResGer.Mood;
                             t : ParamX.Tense}) -> (a : {s : Str; a : ParamX.Anteriority;
                                                         lock_Ant : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.GenNum => Str;
                                                                             c : ResGer.Case;
                                                                             lock_RCl : {}} -> {s : ResGer.GenNum => Str;
                                                                                                c : ResGer.Case;
                                                                                                lock_RS : {}}
                     = 0 ;
                mkRS : (t : {s : Str; lock_Tense : {}; m : ResGer.Mood;
                             t : ParamX.Tense}) -> (p : {s : Str; lock_Pol : {};
                                                         p : ParamX.Polarity}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.GenNum => Str;
                                                                                   c : ResGer.Case;
                                                                                   lock_RCl : {}} -> {s : ResGer.GenNum => Str;
                                                                                                      c : ResGer.Case;
                                                                                                      lock_RS : {}}
                     = 0 ;
                mkRS : (a : {s : Str; a : ParamX.Anteriority;
                             lock_Ant : {}}) -> (p : {s : Str; lock_Pol : {};
                                                      p : ParamX.Polarity}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.GenNum => Str;
                                                                                c : ResGer.Case;
                                                                                lock_RCl : {}} -> {s : ResGer.GenNum => Str;
                                                                                                   c : ResGer.Case;
                                                                                                   lock_RS : {}}
                     = 0 ;
                mkRS : {s : Str; lock_Tense : {}; m : ResGer.Mood;
                        t : ParamX.Tense} -> {s : Str; a : ParamX.Anteriority;
                                              lock_Ant : {}} -> {s : Str; lock_Pol : {};
                                                                 p : ParamX.Polarity} -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.GenNum => Str;
                                                                                          c : ResGer.Case;
                                                                                          lock_RCl : {}} -> {s : ResGer.GenNum => Str;
                                                                                                             c : ResGer.Case;
                                                                                                             lock_RS : {}}
                     = 0 ;
                mkRS : {s : Str; a : ParamX.Anteriority; lock_Temp : {};
                        m : ResGer.Mood; t : ParamX.Tense} -> {s : Str; lock_Pol : {};
                                                               p : ParamX.Polarity} -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.GenNum => Str;
                                                                                        c : ResGer.Case;
                                                                                        lock_RCl : {}} -> {s : ResGer.GenNum => Str;
                                                                                                           c : ResGer.Case;
                                                                                                           lock_RS : {}}
                     = 0 ;
                mkRS : (c : {lock_Conj : {}; n : ParamX.Number; s1 : Str;
                             s2 : Str}) -> (x : {s : ResGer.GenNum => Str; c : ResGer.Case;
                                                 lock_RS : {}}) -> (y : {s : ResGer.GenNum => Str;
                                                                         c : ResGer.Case;
                                                                         lock_RS : {}}) -> {s : ResGer.GenNum => Str;
                                                                                            c : ResGer.Case;
                                                                                            lock_RS : {}}
                     = 0 ;
                mkRS : (c : {lock_Conj : {}; n : ParamX.Number; s1 : Str;
                             s2 : Str}) -> (xy : {c : ResGer.Case; lock_ListRS : {};
                                                  s1 : ResGer.GenNum => Str;
                                                  s2 : ResGer.GenNum => Str}) -> {s : ResGer.GenNum => Str;
                                                                                  c : ResGer.Case;
                                                                                  lock_RS : {}}
                     = 0 ;
              } ;
  oper mkS = overload {
               mkS : {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                      lock_Cl : {}} -> {s : ResGer.Order => Str; lock_S : {}}
                   = 0 ;
               mkS : (t : {s : Str; lock_Tense : {}; m : ResGer.Mood;
                           t : ParamX.Tense}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                  lock_Cl : {}} -> {s : ResGer.Order => Str;
                                                                    lock_S : {}}
                   = 0 ;
               mkS : (a : {s : Str; a : ParamX.Anteriority;
                           lock_Ant : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                               lock_Cl : {}} -> {s : ResGer.Order => Str;
                                                                 lock_S : {}}
                   = 0 ;
               mkS : (p : {s : Str; lock_Pol : {};
                           p : ParamX.Polarity}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                     lock_Cl : {}} -> {s : ResGer.Order => Str;
                                                                       lock_S : {}}
                   = 0 ;
               mkS : (t : {s : Str; lock_Tense : {}; m : ResGer.Mood;
                           t : ParamX.Tense}) -> (a : {s : Str; a : ParamX.Anteriority;
                                                       lock_Ant : {}}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                                           lock_Cl : {}} -> {s : ResGer.Order => Str;
                                                                                             lock_S : {}}
                   = 0 ;
               mkS : (t : {s : Str; lock_Tense : {}; m : ResGer.Mood;
                           t : ParamX.Tense}) -> (p : {s : Str; lock_Pol : {};
                                                       p : ParamX.Polarity}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                                                 lock_Cl : {}} -> {s : ResGer.Order => Str;
                                                                                                   lock_S : {}}
                   = 0 ;
               mkS : (a : {s : Str; a : ParamX.Anteriority;
                           lock_Ant : {}}) -> (p : {s : Str; lock_Pol : {};
                                                    p : ParamX.Polarity}) -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                                              lock_Cl : {}} -> {s : ResGer.Order => Str;
                                                                                                lock_S : {}}
                   = 0 ;
               mkS : (t : {s : Str; lock_Tense : {}; m : ResGer.Mood;
                           t : ParamX.Tense}) -> (a : {s : Str; a : ParamX.Anteriority;
                                                       lock_Ant : {}}) -> {s : Str; lock_Pol : {};
                                                                           p : ParamX.Polarity} -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                                                                    lock_Cl : {}} -> {s : ResGer.Order => Str;
                                                                                                                      lock_S : {}}
                   = 0 ;
               mkS : {s : Str; a : ParamX.Anteriority; lock_Temp : {};
                      m : ResGer.Mood; t : ParamX.Tense} -> {s : Str; lock_Pol : {};
                                                             p : ParamX.Polarity} -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                                                      lock_Cl : {}} -> {s : ResGer.Order => Str;
                                                                                                        lock_S : {}}
                   = 0 ;
               mkS : (c : {lock_Conj : {}; n : ParamX.Number; s1 : Str;
                           s2 : Str}) -> (x : {s : ResGer.Order => Str;
                                               lock_S : {}}) -> (y : {s : ResGer.Order => Str;
                                                                      lock_S : {}}) -> {s : ResGer.Order => Str;
                                                                                        lock_S : {}}
                   = 0 ;
               mkS : (c : {lock_Conj : {}; n : ParamX.Number; s1 : Str;
                           s2 : Str}) -> (xy : {lock_ListS : {}; s1 : ResGer.Order => Str;
                                                s2 : ResGer.Order => Str}) -> {s : ResGer.Order => Str;
                                                                               lock_S : {}}
                   = 0 ;
               mkS : {s : Str; lock_Adv : {}} -> {s : ResGer.Order => Str;
                                                  lock_S : {}} -> {s : ResGer.Order => Str;
                                                                   lock_S : {}}
                   = 0 ;
             } ;
  oper mkSC = overload {
                mkSC : {s : ResGer.Order => Str; lock_S : {}} -> {s : Str;
                                                                  lock_SC : {}}
                     = 0 ;
                mkSC : {s : ParamX.QForm => Str; lock_QS : {}} -> {s : Str;
                                                                   lock_SC : {}}
                     = 0 ;
                mkSC : {s : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                             prefix : Str; vtype : ResGer.VType};
                        a1 : ParamX.Polarity => Str; a2 : Str; ext : Str; inf : Str;
                        isAux : Prelude.Bool; lock_VP : {}; n0 : ResGer.Agr => Str;
                        n2 : ResGer.Agr => Str} -> {s : Str; lock_SC : {}}
                     = 0 ;
              } ;
  oper mkSSlash = overload {
                    mkSSlash : {s : Str; a : ParamX.Anteriority; lock_Temp : {};
                                m : ResGer.Mood; t : ParamX.Tense} -> {s : Str; lock_Pol : {};
                                                                       p : ParamX.Polarity} -> {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                                                                                c2 : {s : Str;
                                                                                                      c : ResGer.PCase};
                                                                                                lock_ClSlash : {}} -> {s : ResGer.Order => Str;
                                                                                                                       c2 : {s : Str;
                                                                                                                             c : ResGer.PCase};
                                                                                                                       lock_SSlash : {}}
                             = 0 ;
                  } ;
  oper mkSub100 = overload {
                    mkSub100 : (n : {d : {s : ResGer.DForm => ResGer.CardOrd => Str;
                                          lock_Digit : {}};
                                     isOne : Predef.PBool;
                                     n : {s : ResGer.DForm => ResGer.CardOrd => Str;
                                          lock_Sub10 : {};
                                          n : ParamX.Number}}) -> {s : ResGer.CardOrd => Str;
                                                                   lock_Sub100 : {};
                                                                   n : ParamX.Number}
                             = 0 ;
                    mkSub100 : (m : {d : {s : ResGer.DForm => ResGer.CardOrd => Str;
                                          lock_Digit : {}};
                                     isOne : Predef.PBool;
                                     n : {s : ResGer.DForm => ResGer.CardOrd => Str;
                                          lock_Sub10 : {};
                                          n : ParamX.Number}}) -> (n : {d : {s : ResGer.DForm => ResGer.CardOrd => Str;
                                                                             lock_Digit : {}};
                                                                        isOne : Predef.PBool;
                                                                        n : {s : ResGer.DForm => ResGer.CardOrd => Str;
                                                                             lock_Sub10 : {};
                                                                             n : ParamX.Number}}) -> {s : ResGer.CardOrd => Str;
                                                                                                      lock_Sub100 : {};
                                                                                                      n : ParamX.Number}
                             = 0 ;
                  } ;
  oper mkSub1000 = overload {
                     mkSub1000 : {s : ResGer.CardOrd => Str; lock_Sub100 : {};
                                  n : ParamX.Number} -> {s : ResGer.CardOrd => Str;
                                                         lock_Sub1000 : {}; n : ParamX.Number}
                               = 0 ;
                     mkSub1000 : (n : {d : {s : ResGer.DForm => ResGer.CardOrd => Str;
                                            lock_Digit : {}};
                                       isOne : Predef.PBool;
                                       n : {s : ResGer.DForm => ResGer.CardOrd => Str;
                                            lock_Sub10 : {};
                                            n : ParamX.Number}}) -> {s : ResGer.CardOrd => Str;
                                                                     lock_Sub1000 : {};
                                                                     n : ParamX.Number}
                               = 0 ;
                     mkSub1000 : (m : {d : {s : ResGer.DForm => ResGer.CardOrd => Str;
                                            lock_Digit : {}};
                                       isOne : Predef.PBool;
                                       n : {s : ResGer.DForm => ResGer.CardOrd => Str;
                                            lock_Sub10 : {};
                                            n : ParamX.Number}}) -> (n : {s : ResGer.CardOrd => Str;
                                                                          lock_Sub100 : {};
                                                                          n : ParamX.Number}) -> {s : ResGer.CardOrd => Str;
                                                                                                  lock_Sub1000 : {};
                                                                                                  n : ParamX.Number}
                               = 0 ;
                   } ;
  oper mkTemp : {s : Str; lock_Tense : {}; m : ResGer.Mood;
                 t : ParamX.Tense} -> {s : Str; a : ParamX.Anteriority;
                                       lock_Ant : {}} -> {s : Str; a : ParamX.Anteriority;
                                                          lock_Temp : {}; m : ResGer.Mood;
                                                          t : ParamX.Tense} ;
  oper mkText = overload {
                  mkText : (phr : {s : Str;
                                   lock_Phr : {}}) -> (punct : ConstructorsGer.Punct) -> (text : {s : Str;
                                                                                                  lock_Text : {}}) -> {s : Str;
                                                                                                                       lock_Text : {}}
                         = 0 ;
                  mkText : (x : {s : Str; lock_Phr : {}}) -> (t : {s : Str;
                                                                   lock_Text : {}}) -> {s : Str;
                                                                                        lock_Text : {}}
                         = 0 ;
                  mkText : (phr : {s : Str;
                                   lock_Phr : {}}) -> (punct : ConstructorsGer.Punct) -> {s : Str;
                                                                                          lock_Text : {}}
                         = 0 ;
                  mkText : (x : {s : Str; lock_Phr : {}}) -> {s : Str;
                                                              lock_Text : {}}
                         = 0 ;
                  mkText : (u : {s : Str; lock_Utt : {}}) -> {s : Str;
                                                              lock_Text : {}}
                         = 0 ;
                  mkText : (s : {s : ResGer.Order => Str; lock_S : {}}) -> {s : Str;
                                                                            lock_Text : {}}
                         = 0 ;
                  mkText : (c : {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                                 lock_Cl : {}}) -> {s : Str; lock_Text : {}}
                         = 0 ;
                  mkText : (q : {s : ParamX.QForm => Str; lock_QS : {}}) -> {s : Str;
                                                                             lock_Text : {}}
                         = 0 ;
                  mkText : (p : {s : Str; lock_Pol : {};
                                 p : ParamX.Polarity}) -> (i : {s : ParamX.Polarity => ParamX.ImpForm => Str;
                                                                lock_Imp : {}}) -> {s : Str;
                                                                                    lock_Text : {}}
                         = 0 ;
                  mkText : (i : {s : ParamX.Polarity => ParamX.ImpForm => Str;
                                 lock_Imp : {}}) -> {s : Str; lock_Text : {}}
                         = 0 ;
                  mkText : (t : {s : Str; lock_Text : {}}) -> (u : {s : Str;
                                                                    lock_Text : {}}) -> {s : Str;
                                                                                         lock_Text : {}}
                         = 0 ;
                } ;
  oper mkUtt = overload {
                 mkUtt : {s : ResGer.Order => Str; lock_S : {}} -> {s : Str;
                                                                    lock_Utt : {}}
                       = 0 ;
                 mkUtt : (c : {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ResGer.Order => Str;
                               lock_Cl : {}}) -> {s : Str; lock_Utt : {}}
                       = 0 ;
                 mkUtt : {s : ParamX.QForm => Str; lock_QS : {}} -> {s : Str;
                                                                     lock_Utt : {}}
                       = 0 ;
                 mkUtt : (c : {s : ResGer.Mood => ParamX.Tense => ParamX.Anteriority => ParamX.Polarity => ParamX.QForm => Str;
                               lock_QCl : {}}) -> {s : Str; lock_Utt : {}}
                       = 0 ;
                 mkUtt : ConstructorsGer.ImpForm -> {s : Str; lock_Pol : {};
                                                     p : ParamX.Polarity} -> {s : ParamX.Polarity => ParamX.ImpForm => Str;
                                                                              lock_Imp : {}} -> {s : Str;
                                                                                                 lock_Utt : {}}
                       = 0 ;
                 mkUtt : (f : ConstructorsGer.ImpForm) -> {s : ParamX.Polarity => ParamX.ImpForm => Str;
                                                           lock_Imp : {}} -> {s : Str;
                                                                              lock_Utt : {}}
                       = 0 ;
                 mkUtt : {s : Str; lock_Pol : {};
                          p : ParamX.Polarity} -> {s : ParamX.Polarity => ParamX.ImpForm => Str;
                                                   lock_Imp : {}} -> {s : Str; lock_Utt : {}}
                       = 0 ;
                 mkUtt : {s : ParamX.Polarity => ParamX.ImpForm => Str;
                          lock_Imp : {}} -> {s : Str; lock_Utt : {}}
                       = 0 ;
                 mkUtt : {s : ResGer.Case => Str; lock_IP : {};
                          n : ParamX.Number} -> {s : Str; lock_Utt : {}}
                       = 0 ;
                 mkUtt : {s : Str; lock_IAdv : {}} -> {s : Str; lock_Utt : {}}
                       = 0 ;
                 mkUtt : {s : ResGer.PCase => Str; a : ResGer.Agr;
                          isPron : Prelude.Bool; lock_NP : {}} -> {s : Str; lock_Utt : {}}
                       = 0 ;
                 mkUtt : {s : Str; lock_Adv : {}} -> {s : Str; lock_Utt : {}}
                       = 0 ;
                 mkUtt : {s : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                               prefix : Str; vtype : ResGer.VType};
                          a1 : ParamX.Polarity => Str; a2 : Str; ext : Str; inf : Str;
                          isAux : Prelude.Bool; lock_VP : {}; n0 : ResGer.Agr => Str;
                          n2 : ResGer.Agr => Str} -> {s : Str; lock_Utt : {}}
                       = 0 ;
                 mkUtt : {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                          g : ResGer.Gender; lock_CN : {}} -> {s : Str; lock_Utt : {}}
                       = 0 ;
                 mkUtt : {s : ResGer.AForm => Str; isPre : Prelude.Bool;
                          lock_AP : {}} -> {s : Str; lock_Utt : {}}
                       = 0 ;
                 mkUtt : {s : ResGer.Gender => ResGer.Case => Str; lock_Card : {};
                          n : ParamX.Number} -> {s : Str; lock_Utt : {}}
                       = 0 ;
               } ;
  oper mkUttImp : ConstructorsGer.ImpForm -> {s : Str; lock_Pol : {};
                                              p : ParamX.Polarity} -> {s : ParamX.Polarity => ParamX.ImpForm => Str;
                                                                       lock_Imp : {}} -> {s : Str;
                                                                                          lock_Utt : {}} ;
  oper mkVP = overload {
                mkVP : {s : ResGer.VForm => Str; aux : ResGer.VAux; lock_V : {};
                        prefix : Str;
                        vtype : ResGer.VType} -> {s : {s : ResGer.VForm => Str;
                                                       aux : ResGer.VAux; prefix : Str;
                                                       vtype : ResGer.VType};
                                                  a1 : ParamX.Polarity => Str; a2 : Str; ext : Str;
                                                  inf : Str; isAux : Prelude.Bool; lock_VP : {};
                                                  n0 : ResGer.Agr => Str; n2 : ResGer.Agr => Str}
                     = 0 ;
                mkVP : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                        c2 : {s : Str; c : ResGer.PCase}; lock_V2 : {}; prefix : Str;
                        vtype : ResGer.VType} -> {s : ResGer.PCase => Str; a : ResGer.Agr;
                                                  isPron : Prelude.Bool;
                                                  lock_NP : {}} -> {s : {s : ResGer.VForm => Str;
                                                                         aux : ResGer.VAux;
                                                                         prefix : Str;
                                                                         vtype : ResGer.VType};
                                                                    a1 : ParamX.Polarity => Str;
                                                                    a2 : Str; ext : Str; inf : Str;
                                                                    isAux : Prelude.Bool;
                                                                    lock_VP : {};
                                                                    n0 : ResGer.Agr => Str;
                                                                    n2 : ResGer.Agr => Str}
                     = 0 ;
                mkVP : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                        c2 : {s : Str; c : ResGer.PCase}; c3 : {s : Str; c : ResGer.PCase};
                        lock_V3 : {}; prefix : Str;
                        vtype : ResGer.VType} -> {s : ResGer.PCase => Str; a : ResGer.Agr;
                                                  isPron : Prelude.Bool;
                                                  lock_NP : {}} -> {s : ResGer.PCase => Str;
                                                                    a : ResGer.Agr;
                                                                    isPron : Prelude.Bool;
                                                                    lock_NP : {}} -> {s : {s : ResGer.VForm => Str;
                                                                                           aux : ResGer.VAux;
                                                                                           prefix : Str;
                                                                                           vtype : ResGer.VType};
                                                                                      a1 : ParamX.Polarity => Str;
                                                                                      a2 : Str;
                                                                                      ext : Str;
                                                                                      inf : Str;
                                                                                      isAux : Prelude.Bool;
                                                                                      lock_VP : {};
                                                                                      n0 : ResGer.Agr => Str;
                                                                                      n2 : ResGer.Agr => Str}
                     = 0 ;
                mkVP : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                        isAux : Prelude.Bool; lock_VV : {}; prefix : Str;
                        vtype : ResGer.VType} -> {s : {s : ResGer.VForm => Str;
                                                       aux : ResGer.VAux; prefix : Str;
                                                       vtype : ResGer.VType};
                                                  a1 : ParamX.Polarity => Str; a2 : Str; ext : Str;
                                                  inf : Str; isAux : Prelude.Bool; lock_VP : {};
                                                  n0 : ResGer.Agr => Str;
                                                  n2 : ResGer.Agr => Str} -> {s : {s : ResGer.VForm => Str;
                                                                                   aux : ResGer.VAux;
                                                                                   prefix : Str;
                                                                                   vtype : ResGer.VType};
                                                                              a1 : ParamX.Polarity => Str;
                                                                              a2 : Str; ext : Str;
                                                                              inf : Str;
                                                                              isAux : Prelude.Bool;
                                                                              lock_VP : {};
                                                                              n0 : ResGer.Agr => Str;
                                                                              n2 : ResGer.Agr => Str}
                     = 0 ;
                mkVP : {s : ResGer.VForm => Str; aux : ResGer.VAux; lock_VS : {};
                        prefix : Str; vtype : ResGer.VType} -> {s : ResGer.Order => Str;
                                                                lock_S : {}} -> {s : {s : ResGer.VForm => Str;
                                                                                      aux : ResGer.VAux;
                                                                                      prefix : Str;
                                                                                      vtype : ResGer.VType};
                                                                                 a1 : ParamX.Polarity => Str;
                                                                                 a2 : Str;
                                                                                 ext : Str;
                                                                                 inf : Str;
                                                                                 isAux : Prelude.Bool;
                                                                                 lock_VP : {};
                                                                                 n0 : ResGer.Agr => Str;
                                                                                 n2 : ResGer.Agr => Str}
                     = 0 ;
                mkVP : {s : ResGer.VForm => Str; aux : ResGer.VAux; lock_VQ : {};
                        prefix : Str; vtype : ResGer.VType} -> {s : ParamX.QForm => Str;
                                                                lock_QS : {}} -> {s : {s : ResGer.VForm => Str;
                                                                                       aux : ResGer.VAux;
                                                                                       prefix : Str;
                                                                                       vtype : ResGer.VType};
                                                                                  a1 : ParamX.Polarity => Str;
                                                                                  a2 : Str;
                                                                                  ext : Str;
                                                                                  inf : Str;
                                                                                  isAux : Prelude.Bool;
                                                                                  lock_VP : {};
                                                                                  n0 : ResGer.Agr => Str;
                                                                                  n2 : ResGer.Agr => Str}
                     = 0 ;
                mkVP : {s : ResGer.VForm => Str; aux : ResGer.VAux; lock_VA : {};
                        prefix : Str; vtype : ResGer.VType} -> {s : ResGer.AForm => Str;
                                                                isPre : Prelude.Bool;
                                                                lock_AP : {}} -> {s : {s : ResGer.VForm => Str;
                                                                                       aux : ResGer.VAux;
                                                                                       prefix : Str;
                                                                                       vtype : ResGer.VType};
                                                                                  a1 : ParamX.Polarity => Str;
                                                                                  a2 : Str;
                                                                                  ext : Str;
                                                                                  inf : Str;
                                                                                  isAux : Prelude.Bool;
                                                                                  lock_VP : {};
                                                                                  n0 : ResGer.Agr => Str;
                                                                                  n2 : ResGer.Agr => Str}
                     = 0 ;
                mkVP : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                        c2 : {s : Str; c : ResGer.PCase}; lock_V2A : {}; prefix : Str;
                        vtype : ResGer.VType} -> {s : ResGer.PCase => Str; a : ResGer.Agr;
                                                  isPron : Prelude.Bool;
                                                  lock_NP : {}} -> {s : ResGer.AForm => Str;
                                                                    isPre : Prelude.Bool;
                                                                    lock_AP : {}} -> {s : {s : ResGer.VForm => Str;
                                                                                           aux : ResGer.VAux;
                                                                                           prefix : Str;
                                                                                           vtype : ResGer.VType};
                                                                                      a1 : ParamX.Polarity => Str;
                                                                                      a2 : Str;
                                                                                      ext : Str;
                                                                                      inf : Str;
                                                                                      isAux : Prelude.Bool;
                                                                                      lock_VP : {};
                                                                                      n0 : ResGer.Agr => Str;
                                                                                      n2 : ResGer.Agr => Str}
                     = 0 ;
                mkVP : (v : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                             c2 : {s : Str; c : ResGer.PCase}; lock_V2S : {}; prefix : Str;
                             vtype : ResGer.VType}) -> (n : {s : ResGer.PCase => Str;
                                                             a : ResGer.Agr; isPron : Prelude.Bool;
                                                             lock_NP : {}}) -> (q : {s : ResGer.Order => Str;
                                                                                     lock_S : {}}) -> {s : {s : ResGer.VForm => Str;
                                                                                                            aux : ResGer.VAux;
                                                                                                            prefix : Str;
                                                                                                            vtype : ResGer.VType};
                                                                                                       a1 : ParamX.Polarity => Str;
                                                                                                       a2 : Str;
                                                                                                       ext : Str;
                                                                                                       inf : Str;
                                                                                                       isAux : Prelude.Bool;
                                                                                                       lock_VP : {};
                                                                                                       n0 : ResGer.Agr => Str;
                                                                                                       n2 : ResGer.Agr => Str}
                     = 0 ;
                mkVP : (v : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                             c2 : {s : Str; c : ResGer.PCase}; lock_V2Q : {}; prefix : Str;
                             vtype : ResGer.VType}) -> (n : {s : ResGer.PCase => Str;
                                                             a : ResGer.Agr; isPron : Prelude.Bool;
                                                             lock_NP : {}}) -> (q : {s : ParamX.QForm => Str;
                                                                                     lock_QS : {}}) -> {s : {s : ResGer.VForm => Str;
                                                                                                             aux : ResGer.VAux;
                                                                                                             prefix : Str;
                                                                                                             vtype : ResGer.VType};
                                                                                                        a1 : ParamX.Polarity => Str;
                                                                                                        a2 : Str;
                                                                                                        ext : Str;
                                                                                                        inf : Str;
                                                                                                        isAux : Prelude.Bool;
                                                                                                        lock_VP : {};
                                                                                                        n0 : ResGer.Agr => Str;
                                                                                                        n2 : ResGer.Agr => Str}
                     = 0 ;
                mkVP : (v : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                             c2 : {s : Str; c : ResGer.PCase}; isAux : Prelude.Bool;
                             lock_V2V : {}; prefix : Str;
                             vtype : ResGer.VType}) -> (n : {s : ResGer.PCase => Str;
                                                             a : ResGer.Agr; isPron : Prelude.Bool;
                                                             lock_NP : {}}) -> (q : {s : {s : ResGer.VForm => Str;
                                                                                          aux : ResGer.VAux;
                                                                                          prefix : Str;
                                                                                          vtype : ResGer.VType};
                                                                                     a1 : ParamX.Polarity => Str;
                                                                                     a2 : Str;
                                                                                     ext : Str;
                                                                                     inf : Str;
                                                                                     isAux : Prelude.Bool;
                                                                                     lock_VP : {};
                                                                                     n0 : ResGer.Agr => Str;
                                                                                     n2 : ResGer.Agr => Str}) -> {s : {s : ResGer.VForm => Str;
                                                                                                                       aux : ResGer.VAux;
                                                                                                                       prefix : Str;
                                                                                                                       vtype : ResGer.VType};
                                                                                                                  a1 : ParamX.Polarity => Str;
                                                                                                                  a2 : Str;
                                                                                                                  ext : Str;
                                                                                                                  inf : Str;
                                                                                                                  isAux : Prelude.Bool;
                                                                                                                  lock_VP : {};
                                                                                                                  n0 : ResGer.Agr => Str;
                                                                                                                  n2 : ResGer.Agr => Str}
                     = 0 ;
                mkVP : (a : {s : ParamX.Degree => ResGer.AForm => Str;
                             lock_A : {}}) -> {s : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                                                    prefix : Str; vtype : ResGer.VType};
                                               a1 : ParamX.Polarity => Str; a2 : Str; ext : Str;
                                               inf : Str; isAux : Prelude.Bool; lock_VP : {};
                                               n0 : ResGer.Agr => Str; n2 : ResGer.Agr => Str}
                     = 0 ;
                mkVP : (y : {s : ParamX.Degree => ResGer.AForm => Str;
                             lock_A : {}}) -> (z : {s : ResGer.PCase => Str; a : ResGer.Agr;
                                                    isPron : Prelude.Bool;
                                                    lock_NP : {}}) -> {s : {s : ResGer.VForm => Str;
                                                                            aux : ResGer.VAux;
                                                                            prefix : Str;
                                                                            vtype : ResGer.VType};
                                                                       a1 : ParamX.Polarity => Str;
                                                                       a2 : Str; ext : Str;
                                                                       inf : Str;
                                                                       isAux : Prelude.Bool;
                                                                       lock_VP : {};
                                                                       n0 : ResGer.Agr => Str;
                                                                       n2 : ResGer.Agr => Str}
                     = 0 ;
                mkVP : (y : {s : ParamX.Degree => ResGer.AForm => Str;
                             c2 : {s : Str; c : ResGer.PCase};
                             lock_A2 : {}}) -> (z : {s : ResGer.PCase => Str; a : ResGer.Agr;
                                                     isPron : Prelude.Bool;
                                                     lock_NP : {}}) -> {s : {s : ResGer.VForm => Str;
                                                                             aux : ResGer.VAux;
                                                                             prefix : Str;
                                                                             vtype : ResGer.VType};
                                                                        a1 : ParamX.Polarity => Str;
                                                                        a2 : Str; ext : Str;
                                                                        inf : Str;
                                                                        isAux : Prelude.Bool;
                                                                        lock_VP : {};
                                                                        n0 : ResGer.Agr => Str;
                                                                        n2 : ResGer.Agr => Str}
                     = 0 ;
                mkVP : (a : {s : ResGer.AForm => Str; isPre : Prelude.Bool;
                             lock_AP : {}}) -> {s : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                                                     prefix : Str; vtype : ResGer.VType};
                                                a1 : ParamX.Polarity => Str; a2 : Str; ext : Str;
                                                inf : Str; isAux : Prelude.Bool; lock_VP : {};
                                                n0 : ResGer.Agr => Str; n2 : ResGer.Agr => Str}
                     = 0 ;
                mkVP : (y : {s : ParamX.Number => ResGer.Case => Str;
                             g : ResGer.Gender; lock_N : {}}) -> {s : {s : ResGer.VForm => Str;
                                                                       aux : ResGer.VAux;
                                                                       prefix : Str;
                                                                       vtype : ResGer.VType};
                                                                  a1 : ParamX.Polarity => Str;
                                                                  a2 : Str; ext : Str; inf : Str;
                                                                  isAux : Prelude.Bool;
                                                                  lock_VP : {};
                                                                  n0 : ResGer.Agr => Str;
                                                                  n2 : ResGer.Agr => Str}
                     = 0 ;
                mkVP : (y : {s : ResGer.Adjf => ParamX.Number => ResGer.Case => Str;
                             g : ResGer.Gender; lock_CN : {}}) -> {s : {s : ResGer.VForm => Str;
                                                                        aux : ResGer.VAux;
                                                                        prefix : Str;
                                                                        vtype : ResGer.VType};
                                                                   a1 : ParamX.Polarity => Str;
                                                                   a2 : Str; ext : Str; inf : Str;
                                                                   isAux : Prelude.Bool;
                                                                   lock_VP : {};
                                                                   n0 : ResGer.Agr => Str;
                                                                   n2 : ResGer.Agr => Str}
                     = 0 ;
                mkVP : (a : {s : ResGer.PCase => Str; a : ResGer.Agr;
                             isPron : Prelude.Bool;
                             lock_NP : {}}) -> {s : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                                                     prefix : Str; vtype : ResGer.VType};
                                                a1 : ParamX.Polarity => Str; a2 : Str; ext : Str;
                                                inf : Str; isAux : Prelude.Bool; lock_VP : {};
                                                n0 : ResGer.Agr => Str; n2 : ResGer.Agr => Str}
                     = 0 ;
                mkVP : (a : {s : Str;
                             lock_Adv : {}}) -> {s : {s : ResGer.VForm => Str;
                                                      aux : ResGer.VAux; prefix : Str;
                                                      vtype : ResGer.VType};
                                                 a1 : ParamX.Polarity => Str; a2 : Str; ext : Str;
                                                 inf : Str; isAux : Prelude.Bool; lock_VP : {};
                                                 n0 : ResGer.Agr => Str; n2 : ResGer.Agr => Str}
                     = 0 ;
                mkVP : {s : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                             prefix : Str; vtype : ResGer.VType};
                        a1 : ParamX.Polarity => Str; a2 : Str; ext : Str; inf : Str;
                        isAux : Prelude.Bool; lock_VP : {}; n0 : ResGer.Agr => Str;
                        n2 : ResGer.Agr => Str} -> {s : Str;
                                                    lock_Adv : {}} -> {s : {s : ResGer.VForm => Str;
                                                                            aux : ResGer.VAux;
                                                                            prefix : Str;
                                                                            vtype : ResGer.VType};
                                                                       a1 : ParamX.Polarity => Str;
                                                                       a2 : Str; ext : Str;
                                                                       inf : Str;
                                                                       isAux : Prelude.Bool;
                                                                       lock_VP : {};
                                                                       n0 : ResGer.Agr => Str;
                                                                       n2 : ResGer.Agr => Str}
                     = 0 ;
                mkVP : {s : Str; lock_AdV : {}} -> {s : {s : ResGer.VForm => Str;
                                                         aux : ResGer.VAux; prefix : Str;
                                                         vtype : ResGer.VType};
                                                    a1 : ParamX.Polarity => Str; a2 : Str;
                                                    ext : Str; inf : Str; isAux : Prelude.Bool;
                                                    lock_VP : {}; n0 : ResGer.Agr => Str;
                                                    n2 : ResGer.Agr => Str} -> {s : {s : ResGer.VForm => Str;
                                                                                     aux : ResGer.VAux;
                                                                                     prefix : Str;
                                                                                     vtype : ResGer.VType};
                                                                                a1 : ParamX.Polarity => Str;
                                                                                a2 : Str; ext : Str;
                                                                                inf : Str;
                                                                                isAux : Prelude.Bool;
                                                                                lock_VP : {};
                                                                                n0 : ResGer.Agr => Str;
                                                                                n2 : ResGer.Agr => Str}
                     = 0 ;
                mkVP : {s : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                             prefix : Str; vtype : ResGer.VType};
                        a1 : ParamX.Polarity => Str; a2 : Str;
                        c2 : {s : Str; c : ResGer.PCase}; ext : Str; inf : Str;
                        isAux : Prelude.Bool; lock_VPSlash : {}; n0 : ResGer.Agr => Str;
                        n2 : ResGer.Agr => Str} -> {s : ResGer.PCase => Str;
                                                    a : ResGer.Agr; isPron : Prelude.Bool;
                                                    lock_NP : {}} -> {s : {s : ResGer.VForm => Str;
                                                                           aux : ResGer.VAux;
                                                                           prefix : Str;
                                                                           vtype : ResGer.VType};
                                                                      a1 : ParamX.Polarity => Str;
                                                                      a2 : Str; ext : Str;
                                                                      inf : Str;
                                                                      isAux : Prelude.Bool;
                                                                      lock_VP : {};
                                                                      n0 : ResGer.Agr => Str;
                                                                      n2 : ResGer.Agr => Str}
                     = 0 ;
                mkVP : {s : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                             prefix : Str; vtype : ResGer.VType};
                        a1 : ParamX.Polarity => Str; a2 : Str;
                        c2 : {s : Str; c : ResGer.PCase}; ext : Str; inf : Str;
                        isAux : Prelude.Bool; lock_VPSlash : {}; n0 : ResGer.Agr => Str;
                        n2 : ResGer.Agr => Str} -> {s : {s : ResGer.VForm => Str;
                                                         aux : ResGer.VAux; prefix : Str;
                                                         vtype : ResGer.VType};
                                                    a1 : ParamX.Polarity => Str; a2 : Str;
                                                    ext : Str; inf : Str; isAux : Prelude.Bool;
                                                    lock_VP : {}; n0 : ResGer.Agr => Str;
                                                    n2 : ResGer.Agr => Str}
                     = 0 ;
                mkVP : {s : ResGer.Agr => Str;
                        lock_Comp : {}} -> {s : {s : ResGer.VForm => Str;
                                                 aux : ResGer.VAux; prefix : Str;
                                                 vtype : ResGer.VType};
                                            a1 : ParamX.Polarity => Str; a2 : Str; ext : Str;
                                            inf : Str; isAux : Prelude.Bool; lock_VP : {};
                                            n0 : ResGer.Agr => Str; n2 : ResGer.Agr => Str}
                     = 0 ;
              } ;
  oper mkVPSlash = overload {
                     mkVPSlash : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                                  c2 : {s : Str; c : ResGer.PCase}; lock_V2 : {}; prefix : Str;
                                  vtype : ResGer.VType} -> {s : {s : ResGer.VForm => Str;
                                                                 aux : ResGer.VAux; prefix : Str;
                                                                 vtype : ResGer.VType};
                                                            a1 : ParamX.Polarity => Str; a2 : Str;
                                                            c2 : {s : Str; c : ResGer.PCase};
                                                            ext : Str; inf : Str;
                                                            isAux : Prelude.Bool; lock_VPSlash : {};
                                                            n0 : ResGer.Agr => Str;
                                                            n2 : ResGer.Agr => Str}
                               = 0 ;
                     mkVPSlash : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                                  c2 : {s : Str; c : ResGer.PCase};
                                  c3 : {s : Str; c : ResGer.PCase}; lock_V3 : {}; prefix : Str;
                                  vtype : ResGer.VType} -> {s : ResGer.PCase => Str; a : ResGer.Agr;
                                                            isPron : Prelude.Bool;
                                                            lock_NP : {}} -> {s : {s : ResGer.VForm => Str;
                                                                                   aux : ResGer.VAux;
                                                                                   prefix : Str;
                                                                                   vtype : ResGer.VType};
                                                                              a1 : ParamX.Polarity => Str;
                                                                              a2 : Str;
                                                                              c2 : {s : Str;
                                                                                    c : ResGer.PCase};
                                                                              ext : Str; inf : Str;
                                                                              isAux : Prelude.Bool;
                                                                              lock_VPSlash : {};
                                                                              n0 : ResGer.Agr => Str;
                                                                              n2 : ResGer.Agr => Str}
                               = 0 ;
                     mkVPSlash : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                                  c2 : {s : Str; c : ResGer.PCase}; lock_V2A : {}; prefix : Str;
                                  vtype : ResGer.VType} -> {s : ResGer.AForm => Str;
                                                            isPre : Prelude.Bool;
                                                            lock_AP : {}} -> {s : {s : ResGer.VForm => Str;
                                                                                   aux : ResGer.VAux;
                                                                                   prefix : Str;
                                                                                   vtype : ResGer.VType};
                                                                              a1 : ParamX.Polarity => Str;
                                                                              a2 : Str;
                                                                              c2 : {s : Str;
                                                                                    c : ResGer.PCase};
                                                                              ext : Str; inf : Str;
                                                                              isAux : Prelude.Bool;
                                                                              lock_VPSlash : {};
                                                                              n0 : ResGer.Agr => Str;
                                                                              n2 : ResGer.Agr => Str}
                               = 0 ;
                     mkVPSlash : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                                  c2 : {s : Str; c : ResGer.PCase}; lock_V2Q : {}; prefix : Str;
                                  vtype : ResGer.VType} -> {s : ParamX.QForm => Str;
                                                            lock_QS : {}} -> {s : {s : ResGer.VForm => Str;
                                                                                   aux : ResGer.VAux;
                                                                                   prefix : Str;
                                                                                   vtype : ResGer.VType};
                                                                              a1 : ParamX.Polarity => Str;
                                                                              a2 : Str;
                                                                              c2 : {s : Str;
                                                                                    c : ResGer.PCase};
                                                                              ext : Str; inf : Str;
                                                                              isAux : Prelude.Bool;
                                                                              lock_VPSlash : {};
                                                                              n0 : ResGer.Agr => Str;
                                                                              n2 : ResGer.Agr => Str}
                               = 0 ;
                     mkVPSlash : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                                  c2 : {s : Str; c : ResGer.PCase}; lock_V2S : {}; prefix : Str;
                                  vtype : ResGer.VType} -> {s : ResGer.Order => Str;
                                                            lock_S : {}} -> {s : {s : ResGer.VForm => Str;
                                                                                  aux : ResGer.VAux;
                                                                                  prefix : Str;
                                                                                  vtype : ResGer.VType};
                                                                             a1 : ParamX.Polarity => Str;
                                                                             a2 : Str;
                                                                             c2 : {s : Str;
                                                                                   c : ResGer.PCase};
                                                                             ext : Str; inf : Str;
                                                                             isAux : Prelude.Bool;
                                                                             lock_VPSlash : {};
                                                                             n0 : ResGer.Agr => Str;
                                                                             n2 : ResGer.Agr => Str}
                               = 0 ;
                     mkVPSlash : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                                  c2 : {s : Str; c : ResGer.PCase}; isAux : Prelude.Bool;
                                  lock_V2V : {}; prefix : Str;
                                  vtype : ResGer.VType} -> {s : {s : ResGer.VForm => Str;
                                                                 aux : ResGer.VAux; prefix : Str;
                                                                 vtype : ResGer.VType};
                                                            a1 : ParamX.Polarity => Str; a2 : Str;
                                                            ext : Str; inf : Str;
                                                            isAux : Prelude.Bool; lock_VP : {};
                                                            n0 : ResGer.Agr => Str;
                                                            n2 : ResGer.Agr => Str} -> {s : {s : ResGer.VForm => Str;
                                                                                             aux : ResGer.VAux;
                                                                                             prefix : Str;
                                                                                             vtype : ResGer.VType};
                                                                                        a1 : ParamX.Polarity => Str;
                                                                                        a2 : Str;
                                                                                        c2 : {s : Str;
                                                                                              c : ResGer.PCase};
                                                                                        ext : Str;
                                                                                        inf : Str;
                                                                                        isAux : Prelude.Bool;
                                                                                        lock_VPSlash : {};
                                                                                        n0 : ResGer.Agr => Str;
                                                                                        n2 : ResGer.Agr => Str}
                               = 0 ;
                     mkVPSlash : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                                  isAux : Prelude.Bool; lock_VV : {}; prefix : Str;
                                  vtype : ResGer.VType} -> {s : {s : ResGer.VForm => Str;
                                                                 aux : ResGer.VAux; prefix : Str;
                                                                 vtype : ResGer.VType};
                                                            a1 : ParamX.Polarity => Str; a2 : Str;
                                                            c2 : {s : Str; c : ResGer.PCase};
                                                            ext : Str; inf : Str;
                                                            isAux : Prelude.Bool; lock_VPSlash : {};
                                                            n0 : ResGer.Agr => Str;
                                                            n2 : ResGer.Agr => Str} -> {s : {s : ResGer.VForm => Str;
                                                                                             aux : ResGer.VAux;
                                                                                             prefix : Str;
                                                                                             vtype : ResGer.VType};
                                                                                        a1 : ParamX.Polarity => Str;
                                                                                        a2 : Str;
                                                                                        c2 : {s : Str;
                                                                                              c : ResGer.PCase};
                                                                                        ext : Str;
                                                                                        inf : Str;
                                                                                        isAux : Prelude.Bool;
                                                                                        lock_VPSlash : {};
                                                                                        n0 : ResGer.Agr => Str;
                                                                                        n2 : ResGer.Agr => Str}
                               = 0 ;
                     mkVPSlash : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                                  c2 : {s : Str; c : ResGer.PCase}; isAux : Prelude.Bool;
                                  lock_V2V : {}; prefix : Str;
                                  vtype : ResGer.VType} -> {s : ResGer.PCase => Str; a : ResGer.Agr;
                                                            isPron : Prelude.Bool;
                                                            lock_NP : {}} -> {s : {s : ResGer.VForm => Str;
                                                                                   aux : ResGer.VAux;
                                                                                   prefix : Str;
                                                                                   vtype : ResGer.VType};
                                                                              a1 : ParamX.Polarity => Str;
                                                                              a2 : Str;
                                                                              c2 : {s : Str;
                                                                                    c : ResGer.PCase};
                                                                              ext : Str; inf : Str;
                                                                              isAux : Prelude.Bool;
                                                                              lock_VPSlash : {};
                                                                              n0 : ResGer.Agr => Str;
                                                                              n2 : ResGer.Agr => Str} -> {s : {s : ResGer.VForm => Str;
                                                                                                               aux : ResGer.VAux;
                                                                                                               prefix : Str;
                                                                                                               vtype : ResGer.VType};
                                                                                                          a1 : ParamX.Polarity => Str;
                                                                                                          a2 : Str;
                                                                                                          c2 : {s : Str;
                                                                                                                c : ResGer.PCase};
                                                                                                          ext : Str;
                                                                                                          inf : Str;
                                                                                                          isAux : Prelude.Bool;
                                                                                                          lock_VPSlash : {};
                                                                                                          n0 : ResGer.Agr => Str;
                                                                                                          n2 : ResGer.Agr => Str}
                               = 0 ;
                   } ;
  oper mkVoc : {s : ResGer.PCase => Str; a : ResGer.Agr;
                isPron : Prelude.Bool; lock_NP : {}} -> {s : Str; lock_Voc : {}} ;
  oper n0_Dig : {s : ResGer.CardOrd => Str; lock_Dig : {};
                 n : ParamX.Number} ;
  oper n1000_Digits : {s : ResGer.CardOrd => Str; lock_Digits : {};
                       n : ParamX.Number} ;
  oper n1000_Numeral : {s : ResGer.CardOrd => Str; lock_Numeral : {};
                        n : ParamX.Number} ;
  oper n100_Digits : {s : ResGer.CardOrd => Str; lock_Digits : {};
                      n : ParamX.Number} ;
  oper n100_Numeral : {s : ResGer.CardOrd => Str; lock_Numeral : {};
                       n : ParamX.Number} ;
  oper n10_Digits : {s : ResGer.CardOrd => Str; lock_Digits : {};
                     n : ParamX.Number} ;
  oper n10_Numeral : {s : ResGer.CardOrd => Str; lock_Numeral : {};
                      n : ParamX.Number} ;
  oper n1_Dig : {s : ResGer.CardOrd => Str; lock_Dig : {};
                 n : ParamX.Number} ;
  oper n1_Digits : {s : ResGer.CardOrd => Str; lock_Digits : {};
                    n : ParamX.Number} ;
  oper n1_Numeral : {s : ResGer.CardOrd => Str; lock_Numeral : {};
                     n : ParamX.Number} ;
  oper n1_Unit : {d : {s : ResGer.DForm => ResGer.CardOrd => Str;
                       lock_Digit : {}};
                  isOne : Predef.PBool;
                  n : {s : ResGer.DForm => ResGer.CardOrd => Str; lock_Sub10 : {};
                       n : ParamX.Number}} ;
  oper n20_Digits : {s : ResGer.CardOrd => Str; lock_Digits : {};
                     n : ParamX.Number} ;
  oper n20_Numeral : {s : ResGer.CardOrd => Str; lock_Numeral : {};
                      n : ParamX.Number} ;
  oper n2_Dig : {s : ResGer.CardOrd => Str; lock_Dig : {};
                 n : ParamX.Number} ;
  oper n2_Digits : {s : ResGer.CardOrd => Str; lock_Digits : {};
                    n : ParamX.Number} ;
  oper n2_Numeral : {s : ResGer.CardOrd => Str; lock_Numeral : {};
                     n : ParamX.Number} ;
  oper n2_Unit : {d : {s : ResGer.DForm => ResGer.CardOrd => Str;
                       lock_Digit : {}};
                  isOne : Predef.PBool;
                  n : {s : ResGer.DForm => ResGer.CardOrd => Str; lock_Sub10 : {};
                       n : ParamX.Number}} ;
  oper n3_Dig : {s : ResGer.CardOrd => Str; lock_Dig : {};
                 n : ParamX.Number} ;
  oper n3_Digits : {s : ResGer.CardOrd => Str; lock_Digits : {};
                    n : ParamX.Number} ;
  oper n3_Numeral : {s : ResGer.CardOrd => Str; lock_Numeral : {};
                     n : ParamX.Number} ;
  oper n3_Unit : {d : {s : ResGer.DForm => ResGer.CardOrd => Str;
                       lock_Digit : {}};
                  isOne : Predef.PBool;
                  n : {s : ResGer.DForm => ResGer.CardOrd => Str; lock_Sub10 : {};
                       n : ParamX.Number}} ;
  oper n4_Dig : {s : ResGer.CardOrd => Str; lock_Dig : {};
                 n : ParamX.Number} ;
  oper n4_Digits : {s : ResGer.CardOrd => Str; lock_Digits : {};
                    n : ParamX.Number} ;
  oper n4_Numeral : {s : ResGer.CardOrd => Str; lock_Numeral : {};
                     n : ParamX.Number} ;
  oper n4_Unit : {d : {s : ResGer.DForm => ResGer.CardOrd => Str;
                       lock_Digit : {}};
                  isOne : Predef.PBool;
                  n : {s : ResGer.DForm => ResGer.CardOrd => Str; lock_Sub10 : {};
                       n : ParamX.Number}} ;
  oper n5_Dig : {s : ResGer.CardOrd => Str; lock_Dig : {};
                 n : ParamX.Number} ;
  oper n5_Digits : {s : ResGer.CardOrd => Str; lock_Digits : {};
                    n : ParamX.Number} ;
  oper n5_Numeral : {s : ResGer.CardOrd => Str; lock_Numeral : {};
                     n : ParamX.Number} ;
  oper n5_Unit : {d : {s : ResGer.DForm => ResGer.CardOrd => Str;
                       lock_Digit : {}};
                  isOne : Predef.PBool;
                  n : {s : ResGer.DForm => ResGer.CardOrd => Str; lock_Sub10 : {};
                       n : ParamX.Number}} ;
  oper n6_Dig : {s : ResGer.CardOrd => Str; lock_Dig : {};
                 n : ParamX.Number} ;
  oper n6_Digits : {s : ResGer.CardOrd => Str; lock_Digits : {};
                    n : ParamX.Number} ;
  oper n6_Numeral : {s : ResGer.CardOrd => Str; lock_Numeral : {};
                     n : ParamX.Number} ;
  oper n6_Unit : {d : {s : ResGer.DForm => ResGer.CardOrd => Str;
                       lock_Digit : {}};
                  isOne : Predef.PBool;
                  n : {s : ResGer.DForm => ResGer.CardOrd => Str; lock_Sub10 : {};
                       n : ParamX.Number}} ;
  oper n7_Dig : {s : ResGer.CardOrd => Str; lock_Dig : {};
                 n : ParamX.Number} ;
  oper n7_Digits : {s : ResGer.CardOrd => Str; lock_Digits : {};
                    n : ParamX.Number} ;
  oper n7_Numeral : {s : ResGer.CardOrd => Str; lock_Numeral : {};
                     n : ParamX.Number} ;
  oper n7_Unit : {d : {s : ResGer.DForm => ResGer.CardOrd => Str;
                       lock_Digit : {}};
                  isOne : Predef.PBool;
                  n : {s : ResGer.DForm => ResGer.CardOrd => Str; lock_Sub10 : {};
                       n : ParamX.Number}} ;
  oper n8_Dig : {s : ResGer.CardOrd => Str; lock_Dig : {};
                 n : ParamX.Number} ;
  oper n8_Digits : {s : ResGer.CardOrd => Str; lock_Digits : {};
                    n : ParamX.Number} ;
  oper n8_Numeral : {s : ResGer.CardOrd => Str; lock_Numeral : {};
                     n : ParamX.Number} ;
  oper n8_Unit : {d : {s : ResGer.DForm => ResGer.CardOrd => Str;
                       lock_Digit : {}};
                  isOne : Predef.PBool;
                  n : {s : ResGer.DForm => ResGer.CardOrd => Str; lock_Sub10 : {};
                       n : ParamX.Number}} ;
  oper n9_Dig : {s : ResGer.CardOrd => Str; lock_Dig : {};
                 n : ParamX.Number} ;
  oper n9_Digits : {s : ResGer.CardOrd => Str; lock_Digits : {};
                    n : ParamX.Number} ;
  oper n9_Numeral : {s : ResGer.CardOrd => Str; lock_Numeral : {};
                     n : ParamX.Number} ;
  oper n9_Unit : {d : {s : ResGer.DForm => ResGer.CardOrd => Str;
                       lock_Digit : {}};
                  isOne : Predef.PBool;
                  n : {s : ResGer.DForm => ResGer.CardOrd => Str; lock_Sub10 : {};
                       n : ParamX.Number}} ;
  oper negativePol : {s : Str; lock_Pol : {}; p : ParamX.Polarity} ;
  oper noPConj : {s : Str; lock_PConj : {}} ;
  oper noVoc : {s : Str; lock_Voc : {}} ;
  oper passiveVP = overload {
                     passiveVP : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                                  c2 : {s : Str; c : ResGer.PCase}; lock_V2 : {}; prefix : Str;
                                  vtype : ResGer.VType} -> {s : {s : ResGer.VForm => Str;
                                                                 aux : ResGer.VAux; prefix : Str;
                                                                 vtype : ResGer.VType};
                                                            a1 : ParamX.Polarity => Str; a2 : Str;
                                                            ext : Str; inf : Str;
                                                            isAux : Prelude.Bool; lock_VP : {};
                                                            n0 : ResGer.Agr => Str;
                                                            n2 : ResGer.Agr => Str}
                               = 0 ;
                     passiveVP : (v : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                                       c2 : {s : Str; c : ResGer.PCase}; lock_V2 : {}; prefix : Str;
                                       vtype : ResGer.VType}) -> (np : {s : ResGer.PCase => Str;
                                                                        a : ResGer.Agr;
                                                                        isPron : Prelude.Bool;
                                                                        lock_NP : {}}) -> {s : {s : ResGer.VForm => Str;
                                                                                                aux : ResGer.VAux;
                                                                                                prefix : Str;
                                                                                                vtype : ResGer.VType};
                                                                                           a1 : ParamX.Polarity => Str;
                                                                                           a2 : Str;
                                                                                           ext : Str;
                                                                                           inf : Str;
                                                                                           isAux : Prelude.Bool;
                                                                                           lock_VP : {};
                                                                                           n0 : ResGer.Agr => Str;
                                                                                           n2 : ResGer.Agr => Str}
                               = 0 ;
                   } ;
  oper plNum : {s : ResGer.Gender => ResGer.Case => Str;
                isNum : Prelude.Bool; lock_Num : {}; n : ParamX.Number} ;
  oper pluralImpForm : ConstructorsGer.ImpForm ;
  oper pluralNum : {s : ResGer.Gender => ResGer.Case => Str;
                    isNum : Prelude.Bool; lock_Num : {}; n : ParamX.Number} ;
  oper politeImpForm : ConstructorsGer.ImpForm ;
  oper positivePol : {s : Str; lock_Pol : {}; p : ParamX.Polarity} ;
  oper presentTense : {s : Str; lock_Tense : {}; m : ResGer.Mood;
                       t : ParamX.Tense} ;
  oper progressiveVP : {s : {s : ResGer.VForm => Str;
                             aux : ResGer.VAux; prefix : Str; vtype : ResGer.VType};
                        a1 : ParamX.Polarity => Str; a2 : Str; ext : Str; inf : Str;
                        isAux : Prelude.Bool; lock_VP : {}; n0 : ResGer.Agr => Str;
                        n2 : ResGer.Agr => Str} -> {s : {s : ResGer.VForm => Str;
                                                         aux : ResGer.VAux; prefix : Str;
                                                         vtype : ResGer.VType};
                                                    a1 : ParamX.Polarity => Str; a2 : Str;
                                                    ext : Str; inf : Str; isAux : Prelude.Bool;
                                                    lock_VP : {}; n0 : ResGer.Agr => Str;
                                                    n2 : ResGer.Agr => Str} ;
  oper questMarkPunct : ConstructorsGer.Punct ;
  oper reflAP : {s : ParamX.Degree => ResGer.AForm => Str;
                 c2 : {s : Str; c : ResGer.PCase};
                 lock_A2 : {}} -> {s : ResGer.AForm => Str; isPre : Prelude.Bool;
                                   lock_AP : {}} ;
  oper reflexiveVP = overload {
                       reflexiveVP : (v : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                                           c2 : {s : Str; c : ResGer.PCase}; lock_V2 : {};
                                           prefix : Str;
                                           vtype : ResGer.VType}) -> {s : {s : ResGer.VForm => Str;
                                                                           aux : ResGer.VAux;
                                                                           prefix : Str;
                                                                           vtype : ResGer.VType};
                                                                      a1 : ParamX.Polarity => Str;
                                                                      a2 : Str; ext : Str;
                                                                      inf : Str;
                                                                      isAux : Prelude.Bool;
                                                                      lock_VP : {};
                                                                      n0 : ResGer.Agr => Str;
                                                                      n2 : ResGer.Agr => Str}
                                   = 0 ;
                       reflexiveVP : {s : {s : ResGer.VForm => Str; aux : ResGer.VAux;
                                           prefix : Str; vtype : ResGer.VType};
                                      a1 : ParamX.Polarity => Str; a2 : Str;
                                      c2 : {s : Str; c : ResGer.PCase}; ext : Str; inf : Str;
                                      isAux : Prelude.Bool; lock_VPSlash : {};
                                      n0 : ResGer.Agr => Str;
                                      n2 : ResGer.Agr => Str} -> {s : {s : ResGer.VForm => Str;
                                                                       aux : ResGer.VAux;
                                                                       prefix : Str;
                                                                       vtype : ResGer.VType};
                                                                  a1 : ParamX.Polarity => Str;
                                                                  a2 : Str; ext : Str; inf : Str;
                                                                  isAux : Prelude.Bool;
                                                                  lock_VP : {};
                                                                  n0 : ResGer.Agr => Str;
                                                                  n2 : ResGer.Agr => Str}
                                   = 0 ;
                     } ;
  oper sgNum : {s : ResGer.Gender => ResGer.Case => Str;
                isNum : Prelude.Bool; lock_Num : {}; n : ParamX.Number} ;
  oper she_NP : {s : ResGer.PCase => Str; a : ResGer.Agr;
                 isPron : Prelude.Bool; lock_NP : {}} ;
  oper simultaneousAnt : {s : Str; a : ParamX.Anteriority;
                          lock_Ant : {}} ;
  oper singularImpForm : ConstructorsGer.ImpForm ;
  oper singularNum : {s : ResGer.Gender => ResGer.Case => Str;
                      isNum : Prelude.Bool; lock_Num : {}; n : ParamX.Number} ;
  oper str2card : Str -> {s : ResGer.Gender => ResGer.Case => Str;
                          lock_Card : {}; n : ParamX.Number} ;
  oper str2digits : Str -> {s : ResGer.CardOrd => Str;
                            lock_Digits : {}; n : ParamX.Number} ;
  oper str2numeral : Str -> {s : ResGer.CardOrd => Str;
                             lock_Numeral : {}; n : ParamX.Number} ;
  oper str2ord : Str -> {s : ResGer.AForm => Str; lock_Ord : {}} ;
  oper tenfoldSub100 : {d : {s : ResGer.DForm => ResGer.CardOrd => Str;
                             lock_Digit : {}};
                        isOne : Predef.PBool;
                        n : {s : ResGer.DForm => ResGer.CardOrd => Str; lock_Sub10 : {};
                             n : ParamX.Number}} -> {s : ResGer.CardOrd => Str;
                                                     lock_Sub100 : {}; n : ParamX.Number} ;
  oper that_Det : {s : ResGer.Gender => ResGer.PCase => Str;
                   a : ResGer.Adjf; lock_Det : {}; n : ParamX.Number;
                   sp : ResGer.Gender => ResGer.PCase => Str} ;
  oper that_NP : {s : ResGer.PCase => Str; a : ResGer.Agr;
                  isPron : Prelude.Bool; lock_NP : {}} ;
  oper that_QuantSg : {s : Prelude.Bool => ParamX.Number => ResGer.Gender => ResGer.PCase => Str;
                       a : ResGer.Adjf; isSg : {}; lock_Quant : {};
                       sp : ParamX.Number => ResGer.Gender => ResGer.PCase => Str} ;
  oper thePl_Det : {s : ResGer.Gender => ResGer.PCase => Str;
                    a : ResGer.Adjf; lock_Det : {}; n : ParamX.Number;
                    sp : ResGer.Gender => ResGer.PCase => Str} ;
  oper theSg_Det : {s : ResGer.Gender => ResGer.PCase => Str;
                    a : ResGer.Adjf; lock_Det : {}; n : ParamX.Number;
                    sp : ResGer.Gender => ResGer.PCase => Str} ;
  oper the_Art : {s : Prelude.Bool => ParamX.Number => ResGer.Gender => ResGer.PCase => Str;
                  a : ResGer.Adjf; lock_Quant : {};
                  sp : ParamX.Number => ResGer.Gender => ResGer.PCase => Str} ;
  oper the_Det : {s : ResGer.Gender => ResGer.PCase => Str;
                  a : ResGer.Adjf; lock_Det : {}; n : ParamX.Number;
                  sp : ResGer.Gender => ResGer.PCase => Str} ;
  oper the_Quant : {s : Prelude.Bool => ParamX.Number => ResGer.Gender => ResGer.PCase => Str;
                    a : ResGer.Adjf; lock_Quant : {};
                    sp : ParamX.Number => ResGer.Gender => ResGer.PCase => Str} ;
  oper these_Det : {s : ResGer.Gender => ResGer.PCase => Str;
                    a : ResGer.Adjf; lock_Det : {}; n : ParamX.Number;
                    sp : ResGer.Gender => ResGer.PCase => Str} ;
  oper these_NP : {s : ResGer.PCase => Str; a : ResGer.Agr;
                   isPron : Prelude.Bool; lock_NP : {}} ;
  oper these_QuantPl : {s : Prelude.Bool => ParamX.Number => ResGer.Gender => ResGer.PCase => Str;
                        a : ResGer.Adjf; isPl : {}; lock_Quant : {};
                        sp : ParamX.Number => ResGer.Gender => ResGer.PCase => Str} ;
  oper they_NP : {s : ResGer.PCase => Str; a : ResGer.Agr;
                  isPron : Prelude.Bool; lock_NP : {}} ;
  oper this_Det : {s : ResGer.Gender => ResGer.PCase => Str;
                   a : ResGer.Adjf; lock_Det : {}; n : ParamX.Number;
                   sp : ResGer.Gender => ResGer.PCase => Str} ;
  oper this_NP : {s : ResGer.PCase => Str; a : ResGer.Agr;
                  isPron : Prelude.Bool; lock_NP : {}} ;
  oper this_QuantSg : {s : Prelude.Bool => ParamX.Number => ResGer.Gender => ResGer.PCase => Str;
                       a : ResGer.Adjf; isSg : {}; lock_Quant : {};
                       sp : ParamX.Number => ResGer.Gender => ResGer.PCase => Str} ;
  oper those_Det : {s : ResGer.Gender => ResGer.PCase => Str;
                    a : ResGer.Adjf; lock_Det : {}; n : ParamX.Number;
                    sp : ResGer.Gender => ResGer.PCase => Str} ;
  oper those_NP : {s : ResGer.PCase => Str; a : ResGer.Agr;
                   isPron : Prelude.Bool; lock_NP : {}} ;
  oper those_QuantPl : {s : Prelude.Bool => ParamX.Number => ResGer.Gender => ResGer.PCase => Str;
                        a : ResGer.Adjf; isPl : {}; lock_Quant : {};
                        sp : ParamX.Number => ResGer.Gender => ResGer.PCase => Str} ;
  oper thousandfoldNumeral : {s : ResGer.CardOrd => Str;
                              lock_Sub1000 : {};
                              n : ParamX.Number} -> {s : ResGer.CardOrd => Str;
                                                     lock_Numeral : {}; n : ParamX.Number} ;
  oper we_NP : {s : ResGer.PCase => Str; a : ResGer.Agr;
                isPron : Prelude.Bool; lock_NP : {}} ;
  oper what_IP : {s : ResGer.Case => Str; lock_IP : {};
                  n : ParamX.Number} ;
  oper whichPl_IDet : {s : ResGer.Gender => ResGer.Case => Str;
                       lock_IDet : {}; n : ParamX.Number} ;
  oper whichSg_IDet : {s : ResGer.Gender => ResGer.Case => Str;
                       lock_IDet : {}; n : ParamX.Number} ;
  oper which_IDet : {s : ResGer.Gender => ResGer.Case => Str;
                     lock_IDet : {}; n : ParamX.Number} ;
  oper which_RP : {s : ResGer.GenNum => ResGer.Case => Str;
                   a : ResGer.RAgr; lock_RP : {}} ;
  oper who_IP : {s : ResGer.Case => Str; lock_IP : {};
                 n : ParamX.Number} ;
  oper youPl_NP : {s : ResGer.PCase => Str; a : ResGer.Agr;
                   isPron : Prelude.Bool; lock_NP : {}} ;
  oper youPol_NP : {s : ResGer.PCase => Str; a : ResGer.Agr;
                    isPron : Prelude.Bool; lock_NP : {}} ;
  oper you_NP : {s : ResGer.PCase => Str; a : ResGer.Agr;
                 isPron : Prelude.Bool; lock_NP : {}} ;
}