resource Prelude = open (Predef = Predef) in {
  flags
    coding = "latin1" ;
  oper BIND : Str ;
  param Bool = True | False ;
  oper CAPIT : Str ;
  param ENumber = E0 | E1 | E2 | Emore ;
  oper PARA : Str ;
  oper SD2 : Type ;
  oper SP1 : Type -> Type ;
  oper SS : Type ;
  oper SS1 : Type -> Type ;
  oper andB : Prelude.Bool -> Prelude.Bool -> Prelude.Bool ;
  oper bothWays : Str -> Str -> Str ;
  oper capitalize : Str -> Str ;
  oper cc2 : {s : Str} -> {s : Str} -> {s : Str} ;
  oper cc3 : {s : Str} -> {s : Str} -> {s : Str} -> {s : Str} ;
  oper constStr : (A : Type) -> Str -> A => Str ;
  oper constTable : (A : Type) -> (B : Type) -> B -> A => B ;
  oper eNext : Prelude.ENumber -> Prelude.ENumber ;
  oper embedSS : Str -> Str -> {s : Str} -> {s : Str} ;
  oper glue : Str -> Str -> Str ;
  oper glueOpt : Str -> Str -> Str ;
  oper id : (A : Type) -> A -> A ;
  oper ifTok : (A : Type) -> Str -> Str -> A -> A -> A ;
  oper if_then_Str : Prelude.Bool -> Str -> Str -> Str ;
  oper if_then_else : (A : Type) -> Prelude.Bool -> A -> A -> A ;
  oper infixSS : Str -> {s : Str} -> {s : Str} -> {s : Str} ;
  oper init : Str -> Str ;
  oper isNil : Str -> Prelude.Bool ;
  oper last : Str -> Str ;
  oper noglueOpt : Str -> Str -> Str ;
  oper nonExist : Str ;
  oper notB : Prelude.Bool -> Prelude.Bool ;
  oper onlyIf : Prelude.Bool -> Str -> Str ;
  oper optStr : Str -> Str ;
  oper orB : Prelude.Bool -> Prelude.Bool -> Prelude.Bool ;
  oper paren : Str -> Str ;
  oper parenss : {s : Str} -> {s : Str} ;
  oper pbool2bool : Predef.PBool -> Prelude.Bool ;
  oper postfixSS : Str -> {s : Str} -> {s : Str} ;
  oper preOrPost : Prelude.Bool -> Str -> Str -> Str ;
  oper prefixSS : Str -> {s : Str} -> {s : Str} ;
  oper sd2 : Str -> Str -> {s1 : Str; s2 : Str} ;
  oper sp1 : (A : Type) -> Str -> A -> {s : Str; p : A} ;
  oper ss : Str -> {s : Str} ;
  oper ss1 : (A : Type) -> Str -> {s : A => Str} ;
  oper ss2 : Str -> Str -> {s : Str} ;
  oper ss3 : Str -> Str -> Str -> {s : Str} ;
  oper strOpt : Str -> Str ;
}