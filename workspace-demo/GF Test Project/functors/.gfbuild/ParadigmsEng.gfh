resource ParadigmsEng = open (Predef = Predef),(Prelude = Prelude),(MorphoEng = MorphoEng),(ResEng = ResEng),(CatEng = CatEng) in {
  flags
    coding = "latin1" ;
  oper A2S : Type ;
  oper A2V : Type ;
  oper ADeg : Type ;
  oper AS : Type ;
  oper AV : Type ;
  oper Case : Type ;
  oper Gender : Type ;
  oper Number : Type ;
  oper Preposition : Type ;
  oper V0 : Type ;
  oper add_s : Str -> Str ;
  oper adegA : {s : ResEng.AForm => Str;
                lock_A : {}} -> {s : ResEng.AForm => Str; lock_A : {}} ;
  oper adj2adv : Str -> Str ;
  oper cnN2 : {s : ParamX.Number => ResEng.Case => Str;
               g : ResEng.Gender; lock_CN : {}} -> {s : Str;
                                                    lock_Prep : {}} -> {s : ParamX.Number => ResEng.Case => Str;
                                                                        c2 : Str; g : ResEng.Gender;
                                                                        lock_N2 : {}} ;
  oper cnN3 : {s : ParamX.Number => ResEng.Case => Str;
               g : ResEng.Gender; lock_CN : {}} -> {s : Str;
                                                    lock_Prep : {}} -> {s : Str;
                                                                        lock_Prep : {}} -> {s : ParamX.Number => ResEng.Case => Str;
                                                                                            c2 : Str;
                                                                                            c3 : Str;
                                                                                            g : ResEng.Gender;
                                                                                            lock_N3 : {}} ;
  oper compoundA : {s : ResEng.AForm => Str;
                    lock_A : {}} -> {s : ResEng.AForm => Str; lock_A : {}} ;
  oper compoundADeg : {s : ResEng.AForm => Str;
                       lock_A : {}} -> {s : ResEng.AForm => Str; lock_A : {}} ;
  oper compoundN : Str -> {s : ParamX.Number => ResEng.Case => Str;
                           g : ResEng.Gender;
                           lock_N : {}} -> {s : ParamX.Number => ResEng.Case => Str;
                                            g : ResEng.Gender; lock_N : {}} ;
  oper dirV2 : {s : ResEng.VForm => Str; isRefl : Prelude.Bool;
                lock_V : {}} -> {s : ResEng.VForm => Str; c2 : Str;
                                 isRefl : Prelude.Bool; lock_V2 : {}} ;
  oper dirV3 : {s : ResEng.VForm => Str; isRefl : Prelude.Bool;
                lock_V : {}} -> {s : Str;
                                 lock_Prep : {}} -> {s : ResEng.VForm => Str; c2 : Str; c3 : Str;
                                                     isRefl : Prelude.Bool; lock_V3 : {}} ;
  oper dirdirV3 : {s : ResEng.VForm => Str; isRefl : Prelude.Bool;
                   lock_V : {}} -> {s : ResEng.VForm => Str; c2 : Str; c3 : Str;
                                    isRefl : Prelude.Bool; lock_V3 : {}} ;
  oper duplADeg : Str -> {s : ResEng.AForm => Str; lock_A : {}} ;
  oper duplFinal : Str -> Str ;
  oper feminine : ResEng.Gender ;
  oper genderN : ResEng.Gender -> {s : ParamX.Number => ResEng.Case => Str;
                                   g : ResEng.Gender;
                                   lock_N : {}} -> {s : ParamX.Number => ResEng.Case => Str;
                                                    g : ResEng.Gender; lock_N : {}} ;
  oper genitive : ResEng.NPCase ;
  oper human : ResEng.Gender ;
  oper ingV2V : {s : ResEng.VForm => Str; isRefl : Prelude.Bool;
                 lock_V : {}} -> {s : Str; lock_Prep : {}} -> {s : Str;
                                                               lock_Prep : {}} -> {s : ResEng.VForm => Str;
                                                                                   c2 : Str;
                                                                                   c3 : Str;
                                                                                   isRefl : Prelude.Bool;
                                                                                   lock_V2V : {};
                                                                                   typ : ResEng.VVType} ;
  oper ingVV : {s : ResEng.VForm => Str; isRefl : Prelude.Bool;
                lock_V : {}} -> {s : ResEng.VVForm => Str; lock_VV : {};
                                 typ : ResEng.VVType} ;
  oper irreg4V : (run : Str) -> (ran : Str) -> (run : Str) -> (running : Str) -> {s : ResEng.VForm => Str;
                                                                                  isRefl : Prelude.Bool;
                                                                                  lock_V : {}} ;
  oper irregAdv : {s : ResEng.AForm => Str;
                   lock_A : {}} -> Str -> {s : ResEng.AForm => Str; lock_A : {}} ;
  oper irregDuplV : (get : Str) -> (got : Str) -> (gotten : Str) -> {s : ResEng.VForm => Str;
                                                                     isRefl : Prelude.Bool;
                                                                     lock_V : {}} ;
  oper irregV : (drink : Str) -> (drank : Str) -> (drunk : Str) -> {s : ResEng.VForm => Str;
                                                                    isRefl : Prelude.Bool;
                                                                    lock_V : {}} ;
  oper masculine : ResEng.Gender ;
  oper mk2A : (free : Str) -> (freely : Str) -> {s : ResEng.AForm => Str;
                                                 lock_A : {}} ;
  oper mk2Conj : Str -> Str -> ParamX.Number -> {lock_Conj : {};
                                                 n : ParamX.Number; s1 : Str; s2 : Str} ;
  oper mk2N : (man : Str) -> (men : Str) -> {s : ParamX.Number => ResEng.Case => Str;
                                             g : ResEng.Gender; lock_N : {}} ;
  oper mk4N : (man : Str) -> (men : Str) -> (man's : Str) -> (men's : Str) -> {s : ParamX.Number => ResEng.Case => Str;
                                                                               g : ResEng.Gender;
                                                                               lock_N : {}} ;
  oper mk5V : (go : Str) -> (goes : Str) -> (went : Str) -> (gone : Str) -> (going : Str) -> {s : ResEng.VForm => Str;
                                                                                              isRefl : Prelude.Bool;
                                                                                              lock_V : {}} ;
  oper mkA = overload {
               mkA : Str -> {s : ResEng.AForm => Str; lock_A : {}}
                   = 0 ;
               mkA : (fat : Str) -> (fatter : Str) -> {s : ResEng.AForm => Str;
                                                       lock_A : {}}
                   = 0 ;
               mkA : (a : Str) -> (b : Str) -> (c : Str) -> (d : Str) -> {s : ResEng.AForm => Str;
                                                                          lock_A : {}}
                   = 0 ;
             } ;
  oper mkA2 = overload {
                mkA2 : {s : ResEng.AForm => Str; lock_A : {}} -> {s : Str;
                                                                  lock_Prep : {}} -> {s : ResEng.AForm => Str;
                                                                                      c2 : Str;
                                                                                      lock_A2 : {}}
                     = 0 ;
                mkA2 : (a : {s : ResEng.AForm => Str;
                             lock_A : {}}) -> (p : Str) -> {s : ResEng.AForm => Str; c2 : Str;
                                                            lock_A2 : {}}
                     = 0 ;
                mkA2 : (a : Str) -> (p : {s : Str;
                                          lock_Prep : {}}) -> {s : ResEng.AForm => Str; c2 : Str;
                                                               lock_A2 : {}}
                     = 0 ;
                mkA2 : (a : Str) -> (p : Str) -> {s : ResEng.AForm => Str;
                                                  c2 : Str; lock_A2 : {}}
                     = 0 ;
              } ;
  oper mkA2S : {s : ResEng.AForm => Str; lock_A : {}} -> {s : Str;
                                                          lock_Prep : {}} -> {s : ResEng.AForm => Str;
                                                                              lock_A : {}} ;
  oper mkA2V : {s : ResEng.AForm => Str; lock_A : {}} -> {s : Str;
                                                          lock_Prep : {}} -> {s : ResEng.AForm => Str;
                                                                              c2 : Str;
                                                                              lock_A2 : {}} ;
  oper mkADeg : (good : Str) -> (better : Str) -> (best : Str) -> (well : Str) -> {s : ResEng.AForm => Str;
                                                                                   lock_A : {}} ;
  oper mkAS : {s : ResEng.AForm => Str;
               lock_A : {}} -> {s : ResEng.AForm => Str; lock_A : {}} ;
  oper mkAV : {s : ResEng.AForm => Str;
               lock_A : {}} -> {s : ResEng.AForm => Str; lock_A : {}} ;
  oper mkAdA : Str -> {s : Str; lock_AdA : {}} ;
  oper mkAdN : Str -> {s : Str; lock_AdN : {}} ;
  oper mkAdV : Str -> {s : Str; lock_AdV : {}} ;
  oper mkAdv : Str -> {s : Str; lock_Adv : {}} ;
  oper mkConj = overload {
                  mkConj : (y : Str) -> {lock_Conj : {}; n : ParamX.Number; s1 : Str;
                                         s2 : Str}
                         = 0 ;
                  mkConj : (y : Str) -> (n : ParamX.Number) -> {lock_Conj : {};
                                                                n : ParamX.Number; s1 : Str;
                                                                s2 : Str}
                         = 0 ;
                  mkConj : (x : Str) -> (y : Str) -> {lock_Conj : {};
                                                      n : ParamX.Number; s1 : Str; s2 : Str}
                         = 0 ;
                  mkConj : Str -> Str -> ParamX.Number -> {lock_Conj : {};
                                                           n : ParamX.Number; s1 : Str; s2 : Str}
                         = 0 ;
                } ;
  oper mkN = overload {
               mkN : (man : Str) -> (men : Str) -> (man's : Str) -> (men's : Str) -> {s : ParamX.Number => ResEng.Case => Str;
                                                                                      g : ResEng.Gender;
                                                                                      lock_N : {}}
                   = 0 ;
               mkN : Str -> {s : ParamX.Number => ResEng.Case => Str;
                             g : ResEng.Gender; lock_N : {}}
                   = 0 ;
               mkN : (man : Str) -> (men : Str) -> {s : ParamX.Number => ResEng.Case => Str;
                                                    g : ResEng.Gender; lock_N : {}}
                   = 0 ;
               mkN : ResEng.Gender -> {s : ParamX.Number => ResEng.Case => Str;
                                       g : ResEng.Gender;
                                       lock_N : {}} -> {s : ParamX.Number => ResEng.Case => Str;
                                                        g : ResEng.Gender; lock_N : {}}
                   = 0 ;
               mkN : Str -> {s : ParamX.Number => ResEng.Case => Str;
                             g : ResEng.Gender;
                             lock_N : {}} -> {s : ParamX.Number => ResEng.Case => Str;
                                              g : ResEng.Gender; lock_N : {}}
                   = 0 ;
             } ;
  oper mkN2 = overload {
                mkN2 : {s : ParamX.Number => ResEng.Case => Str; g : ResEng.Gender;
                        lock_N : {}} -> {s : Str;
                                         lock_Prep : {}} -> {s : ParamX.Number => ResEng.Case => Str;
                                                             c2 : Str; g : ResEng.Gender;
                                                             lock_N2 : {}}
                     = 0 ;
                mkN2 : (n : {s : ParamX.Number => ResEng.Case => Str;
                             g : ResEng.Gender;
                             lock_N : {}}) -> (s : Str) -> {s : ParamX.Number => ResEng.Case => Str;
                                                            c2 : Str; g : ResEng.Gender;
                                                            lock_N2 : {}}
                     = 0 ;
                mkN2 : (n : Str) -> (s : Str) -> {s : ParamX.Number => ResEng.Case => Str;
                                                  c2 : Str; g : ResEng.Gender; lock_N2 : {}}
                     = 0 ;
                mkN2 : (n : {s : ParamX.Number => ResEng.Case => Str;
                             g : ResEng.Gender;
                             lock_N : {}}) -> {s : ParamX.Number => ResEng.Case => Str;
                                               c2 : Str; g : ResEng.Gender; lock_N2 : {}}
                     = 0 ;
                mkN2 : (s : Str) -> {s : ParamX.Number => ResEng.Case => Str;
                                     c2 : Str; g : ResEng.Gender; lock_N2 : {}}
                     = 0 ;
              } ;
  oper mkN3 : {s : ParamX.Number => ResEng.Case => Str;
               g : ResEng.Gender; lock_N : {}} -> {s : Str;
                                                   lock_Prep : {}} -> {s : Str;
                                                                       lock_Prep : {}} -> {s : ParamX.Number => ResEng.Case => Str;
                                                                                           c2 : Str;
                                                                                           c3 : Str;
                                                                                           g : ResEng.Gender;
                                                                                           lock_N3 : {}} ;
  oper mkOrd : Str -> {s : ResEng.Case => Str; lock_Ord : {}} ;
  oper mkPN = overload {
                mkPN : Str -> {s : ResEng.Case => Str; g : ResEng.Gender;
                               lock_PN : {}}
                     = 0 ;
                mkPN : {s : ParamX.Number => ResEng.Case => Str; g : ResEng.Gender;
                        lock_N : {}} -> {s : ResEng.Case => Str; g : ResEng.Gender;
                                         lock_PN : {}}
                     = 0 ;
              } ;
  oper mkPrep : Str -> {s : Str; lock_Prep : {}} ;
  oper mkQuant = overload {
                   mkQuant : (sg : Str) -> (pl : Str) -> {s : Prelude.Bool => ParamX.Number => Str;
                                                          lock_Quant : {};
                                                          sp : Prelude.Bool => ParamX.Number => ResEng.NPCase => Str}
                           = 0 ;
                   mkQuant : (no_sg : Str) -> (no_pl : Str) -> (none_sg : Str) -> (non_pl : Str) -> {s : Prelude.Bool => ParamX.Number => Str;
                                                                                                     lock_Quant : {};
                                                                                                     sp : Prelude.Bool => ParamX.Number => ResEng.NPCase => Str}
                           = 0 ;
                 } ;
  oper mkQuantifier : Str -> Str -> Str -> Str -> {s : Prelude.Bool => ParamX.Number => Str;
                                                   lock_Quant : {};
                                                   sp : Prelude.Bool => ParamX.Number => ResEng.NPCase => Str} ;
  oper mkSubj : Str -> {s : Str; lock_Subj : {}} ;
  oper mkV = overload {
               mkV : (cry : Str) -> {s : ResEng.VForm => Str;
                                     isRefl : Prelude.Bool; lock_V : {}}
                   = 0 ;
               mkV : (stop : Str) -> (stopped : Str) -> {s : ResEng.VForm => Str;
                                                         isRefl : Prelude.Bool; lock_V : {}}
                   = 0 ;
               mkV : (drink : Str) -> (drank : Str) -> (drunk : Str) -> {s : ResEng.VForm => Str;
                                                                         isRefl : Prelude.Bool;
                                                                         lock_V : {}}
                   = 0 ;
               mkV : (run : Str) -> (ran : Str) -> (run : Str) -> (running : Str) -> {s : ResEng.VForm => Str;
                                                                                      isRefl : Prelude.Bool;
                                                                                      lock_V : {}}
                   = 0 ;
               mkV : (go : Str) -> (goes : Str) -> (went : Str) -> (gone : Str) -> (going : Str) -> {s : ResEng.VForm => Str;
                                                                                                     isRefl : Prelude.Bool;
                                                                                                     lock_V : {}}
                   = 0 ;
               mkV : Str -> {s : ResEng.VForm => Str; isRefl : Prelude.Bool;
                             lock_V : {}} -> {s : ResEng.VForm => Str; isRefl : Prelude.Bool;
                                              lock_V : {}}
                   = 0 ;
             } ;
  oper mkV0 : {s : ResEng.VForm => Str; isRefl : Prelude.Bool;
               lock_V : {}} -> {s : ResEng.VForm => Str; isRefl : Prelude.Bool;
                                lock_V : {}} ;
  oper mkV2 = overload {
                mkV2 : {s : ResEng.VForm => Str; isRefl : Prelude.Bool;
                        lock_V : {}} -> {s : ResEng.VForm => Str; c2 : Str;
                                         isRefl : Prelude.Bool; lock_V2 : {}}
                     = 0 ;
                mkV2 : (s : Str) -> {s : ResEng.VForm => Str; c2 : Str;
                                     isRefl : Prelude.Bool; lock_V2 : {}}
                     = 0 ;
                mkV2 : {s : ResEng.VForm => Str; isRefl : Prelude.Bool;
                        lock_V : {}} -> {s : Str;
                                         lock_Prep : {}} -> {s : ResEng.VForm => Str; c2 : Str;
                                                             isRefl : Prelude.Bool; lock_V2 : {}}
                     = 0 ;
                mkV2 : (v : {s : ResEng.VForm => Str; isRefl : Prelude.Bool;
                             lock_V : {}}) -> (p : Str) -> {s : ResEng.VForm => Str; c2 : Str;
                                                            isRefl : Prelude.Bool; lock_V2 : {}}
                     = 0 ;
                mkV2 : (v : Str) -> (p : {s : Str;
                                          lock_Prep : {}}) -> {s : ResEng.VForm => Str; c2 : Str;
                                                               isRefl : Prelude.Bool; lock_V2 : {}}
                     = 0 ;
                mkV2 : (v : Str) -> (p : Str) -> {s : ResEng.VForm => Str;
                                                  c2 : Str; isRefl : Prelude.Bool; lock_V2 : {}}
                     = 0 ;
              } ;
  oper mkV2A : {s : ResEng.VForm => Str; isRefl : Prelude.Bool;
                lock_V : {}} -> {s : Str;
                                 lock_Prep : {}} -> {s : ResEng.VForm => Str; c2 : Str;
                                                     isRefl : Prelude.Bool; lock_V2A : {}} ;
  oper mkV2Q : {s : ResEng.VForm => Str; isRefl : Prelude.Bool;
                lock_V : {}} -> {s : Str;
                                 lock_Prep : {}} -> {s : ResEng.VForm => Str; c2 : Str;
                                                     isRefl : Prelude.Bool; lock_V2Q : {}} ;
  oper mkV2S : {s : ResEng.VForm => Str; isRefl : Prelude.Bool;
                lock_V : {}} -> {s : Str;
                                 lock_Prep : {}} -> {s : ResEng.VForm => Str; c2 : Str;
                                                     isRefl : Prelude.Bool; lock_V2S : {}} ;
  oper mkV2V : {s : ResEng.VForm => Str; isRefl : Prelude.Bool;
                lock_V : {}} -> {s : Str; lock_Prep : {}} -> {s : Str;
                                                              lock_Prep : {}} -> {s : ResEng.VForm => Str;
                                                                                  c2 : Str;
                                                                                  c3 : Str;
                                                                                  isRefl : Prelude.Bool;
                                                                                  lock_V2V : {};
                                                                                  typ : ResEng.VVType} ;
  oper mkV3 = overload {
                mkV3 : {s : ResEng.VForm => Str; isRefl : Prelude.Bool;
                        lock_V : {}} -> {s : Str; lock_Prep : {}} -> {s : Str;
                                                                      lock_Prep : {}} -> {s : ResEng.VForm => Str;
                                                                                          c2 : Str;
                                                                                          c3 : Str;
                                                                                          isRefl : Prelude.Bool;
                                                                                          lock_V3 : {}}
                     = 0 ;
                mkV3 : {s : ResEng.VForm => Str; isRefl : Prelude.Bool;
                        lock_V : {}} -> {s : Str;
                                         lock_Prep : {}} -> {s : ResEng.VForm => Str; c2 : Str;
                                                             c3 : Str; isRefl : Prelude.Bool;
                                                             lock_V3 : {}}
                     = 0 ;
                mkV3 : (v : {s : ResEng.VForm => Str; isRefl : Prelude.Bool;
                             lock_V : {}}) -> (s : Str) -> {s : ResEng.VForm => Str; c2 : Str;
                                                            c3 : Str; isRefl : Prelude.Bool;
                                                            lock_V3 : {}}
                     = 0 ;
                mkV3 : (v : Str) -> (s : Str) -> {s : ResEng.VForm => Str;
                                                  c2 : Str; c3 : Str; isRefl : Prelude.Bool;
                                                  lock_V3 : {}}
                     = 0 ;
                mkV3 : {s : ResEng.VForm => Str; isRefl : Prelude.Bool;
                        lock_V : {}} -> {s : ResEng.VForm => Str; c2 : Str; c3 : Str;
                                         isRefl : Prelude.Bool; lock_V3 : {}}
                     = 0 ;
                mkV3 : (v : Str) -> {s : ResEng.VForm => Str; c2 : Str; c3 : Str;
                                     isRefl : Prelude.Bool; lock_V3 : {}}
                     = 0 ;
              } ;
  oper mkVA : {s : ResEng.VForm => Str; isRefl : Prelude.Bool;
               lock_V : {}} -> {s : ResEng.VForm => Str; isRefl : Prelude.Bool;
                                lock_VA : {}} ;
  oper mkVQ : {s : ResEng.VForm => Str; isRefl : Prelude.Bool;
               lock_V : {}} -> {s : ResEng.VForm => Str; isRefl : Prelude.Bool;
                                lock_VQ : {}} ;
  oper mkVS : {s : ResEng.VForm => Str; isRefl : Prelude.Bool;
               lock_V : {}} -> {s : ResEng.VForm => Str; isRefl : Prelude.Bool;
                                lock_VS : {}} ;
  oper mkVV : {s : ResEng.VForm => Str; isRefl : Prelude.Bool;
               lock_V : {}} -> {s : ResEng.VVForm => Str; lock_VV : {};
                                typ : ResEng.VVType} ;
  oper noPrep : {s : Str; lock_Prep : {}} ;
  oper nominative : ResEng.NPCase ;
  oper nonhuman : ResEng.Gender ;
  oper nounPN : {s : ParamX.Number => ResEng.Case => Str;
                 g : ResEng.Gender; lock_N : {}} -> {s : ResEng.Case => Str;
                                                     g : ResEng.Gender; lock_PN : {}} ;
  oper npNumber : {s : ResEng.NPCase => Str; a : ResEng.Agr;
                   lock_NP : {}} -> ParamX.Number ;
  oper partV : {s : ResEng.VForm => Str; isRefl : Prelude.Bool;
                lock_V : {}} -> Str -> {s : ResEng.VForm => Str;
                                        isRefl : Prelude.Bool; lock_V : {}} ;
  oper plural : ParamX.Number ;
  oper prefixV : Str -> {s : ResEng.VForm => Str;
                         isRefl : Prelude.Bool; lock_V : {}} -> {s : ResEng.VForm => Str;
                                                                 isRefl : Prelude.Bool;
                                                                 lock_V : {}} ;
  oper prepA2 : {s : ResEng.AForm => Str; lock_A : {}} -> {s : Str;
                                                           lock_Prep : {}} -> {s : ResEng.AForm => Str;
                                                                               c2 : Str;
                                                                               lock_A2 : {}} ;
  oper prepN2 : {s : ParamX.Number => ResEng.Case => Str;
                 g : ResEng.Gender; lock_N : {}} -> {s : Str;
                                                     lock_Prep : {}} -> {s : ParamX.Number => ResEng.Case => Str;
                                                                         c2 : Str;
                                                                         g : ResEng.Gender;
                                                                         lock_N2 : {}} ;
  oper prepPrepV3 : {s : ResEng.VForm => Str; isRefl : Prelude.Bool;
                     lock_V : {}} -> {s : Str; lock_Prep : {}} -> {s : Str;
                                                                   lock_Prep : {}} -> {s : ResEng.VForm => Str;
                                                                                       c2 : Str;
                                                                                       c3 : Str;
                                                                                       isRefl : Prelude.Bool;
                                                                                       lock_V3 : {}} ;
  oper prepV2 : {s : ResEng.VForm => Str; isRefl : Prelude.Bool;
                 lock_V : {}} -> {s : Str;
                                  lock_Prep : {}} -> {s : ResEng.VForm => Str; c2 : Str;
                                                      isRefl : Prelude.Bool; lock_V2 : {}} ;
  oper reflV : {s : ResEng.VForm => Str; isRefl : Prelude.Bool;
                lock_V : {}} -> {s : ResEng.VForm => Str; isRefl : Prelude.Bool;
                                 lock_V : {}} ;
  oper reg2V : (stop : Str) -> (stopped : Str) -> {s : ResEng.VForm => Str;
                                                   isRefl : Prelude.Bool; lock_V : {}} ;
  oper regA : Str -> {s : ResEng.AForm => Str; lock_A : {}} ;
  oper regADeg : Str -> {s : ResEng.AForm => Str; lock_A : {}} ;
  oper regDuplV : Str -> {s : ResEng.VForm => Str;
                          isRefl : Prelude.Bool; lock_V : {}} ;
  oper regGenPN : Str -> ResEng.Gender -> {s : ResEng.Case => Str;
                                           g : ResEng.Gender; lock_PN : {}} ;
  oper regN : Str -> {s : ParamX.Number => ResEng.Case => Str;
                      g : ResEng.Gender; lock_N : {}} ;
  oper regN2 : Str -> {s : ParamX.Number => ResEng.Case => Str;
                       c2 : Str; g : ResEng.Gender; lock_N2 : {}} ;
  oper regPN : Str -> {s : ResEng.Case => Str; g : ResEng.Gender;
                       lock_PN : {}} ;
  oper regV : (cry : Str) -> {s : ResEng.VForm => Str;
                              isRefl : Prelude.Bool; lock_V : {}} ;
  oper simpleA : {s : ResEng.AForm => Str;
                  lock_A : {}} -> {s : ResEng.AForm => Str; lock_A : {}} ;
  oper singular : ParamX.Number ;
}