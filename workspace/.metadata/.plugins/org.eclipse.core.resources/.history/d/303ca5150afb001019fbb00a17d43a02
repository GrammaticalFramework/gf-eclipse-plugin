package org.grammaticalframework.eclipse.builder;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.ArrayList;
import java.util.Map;
import java.util.concurrent.Callable;

import org.eclipse.core.resources.IContainer;
import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IFolder;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.IResourceDelta;
import org.eclipse.core.resources.IResourceDeltaVisitor;
import org.eclipse.core.resources.IncrementalProjectBuilder;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.Platform;
import org.eclipse.core.runtime.preferences.IPreferencesService;
import org.grammaticalframework.eclipse.launch.IGFLaunchConfigConstants;

/**
 * Custom GF builder, yeah!
 * Some refs..
 * 	http://wiki.eclipse.org/FAQ_How_do_I_implement_an_incremental_project_builder%3F
 * 	http://www.eclipse.org/articles/Article-Builders/builders.html
 * 
 * TODO Adding of makers to files
 * TODO Should this class actually be moved to the UI plugin?
 * 
 * @author John J. Camilleri
 *
 */
public class GFBuilder extends IncrementalProjectBuilder {

	public static final String BUILDER_ID = "org.grammaticalframework.eclipse.ui.build.GFBuilderID"; //$NON-NLS-1$

	public static final String BUILD_FOLDER = ".gfbuild"; //$NON-NLS-1$
	
	private String gfPath;


	@Override
	protected IProject[] build(int kind, Map<String, String> args, IProgressMonitor monitor) throws CoreException {
		
		// Make sure a GF path is set
		IPreferencesService prefs = Platform.getPreferencesService();
		String defaultGFPath = "/home/john/.cabal/bin/gf"; // TODO hardcoded just for testing!
		gfPath = prefs.getString("org.grammaticalframework.eclipse.GF", "runtimePath", defaultGFPath, null);
		if (gfPath == null || gfPath.trim().isEmpty()) {
			System.out.println("Error during build: GF path not specified.");
			return null;
		}
		
		if (kind == IncrementalProjectBuilder.FULL_BUILD) {
			fullBuild(monitor);
		} else {
			IResourceDelta delta = getDelta(getProject());
			if (delta == null) {
				fullBuild(monitor);
			} else {
				incrementalBuild(delta, monitor);
			}
		}
		return null;
	}

	private void incrementalBuild(IResourceDelta delta, IProgressMonitor monitor) {
		System.out.println("Incremental build on " + delta);
		try {
			delta.accept(new IResourceDeltaVisitor() {
				public boolean visit(IResourceDelta delta) {
					IResource resource = delta.getResource();
					int kind = delta.getKind(); 
					if (kind == IResourceDelta.ADDED || kind == IResourceDelta.CHANGED) {
						if (shouldBuild(resource)) {
							System.out.println("  - " + delta.getResource().getRawLocation());
							buildFile((IFile)resource);
						}
						
					}
					return true; // visit children too
				}
			});
			getProject().refreshLocal(IResource.DEPTH_INFINITE, monitor);
		} catch (CoreException e) {
			e.printStackTrace();
		}
	}

	private void fullBuild(IProgressMonitor monitor) throws CoreException {
		System.out.println("Full build on " + getProject().getName());
		recursiveDispatcher(getProject().members(), new CallableOnResource() {
			public void call(IResource resource) {
				if (shouldBuild(resource)) {
					System.out.println("  - " + resource.getName());
					buildFile((IFile)resource);
				}
			}
		});
		getProject().refreshLocal(IResource.DEPTH_INFINITE, monitor);
	}
	
	@Override
	protected void clean(final IProgressMonitor monitor) throws CoreException {
		System.out.println("Clean " + getProject().getName());
		
		// TODO Delete markers with getProject().deleteMarkers()
		
		recursiveDispatcher(getProject().members(), new CallableOnResource() {
			public void call(IResource resource) {
				if (resource.getType() == IResource.FILE && resource.getFileExtension().equals("gfh")) {
					try {
						resource.delete(true, monitor);
						System.out.println("  - deleted " + resource.getName());
					} catch (CoreException e) {
						System.out.println("  - failed to delete " + resource.getName());
						e.printStackTrace();
					}
				}
			}
		});
	}
//	private void recursiveClean(IResource[] res, CallableOnResource func) {
//		try {
//			for (IResource r : res) {
//				if (r.getType() == IResource.FOLDER) {
//					recursiveDispatcher(((IFolder)r).members(), func);
//				} else {
//					func.call(r);
//				}
//			}
//		} catch (CoreException e) {
//			e.printStackTrace();
//		}
//	}
//	   
	
	/**
	 * For recursively applying a function to an IResource 
	 *
	 */
	interface CallableOnResource {
		public void call(IResource resource);
	}
	private void recursiveDispatcher(IResource[] res, CallableOnResource func) {
		try {
			for (IResource r : res) {
				if (r.getType() == IResource.FOLDER) {
					recursiveDispatcher(((IFolder)r).members(), func);
				} else {
					func.call(r);
				}
			}
		} catch (CoreException e) {
			e.printStackTrace();
		}
	}
	
	/**
	 * Determine if a resource should be built, based on its properties
	 * @param resource
	 * @return
	 */
	private boolean shouldBuild(IResource resource) {
		return resource.getType() == IResource.FILE && resource.getFileExtension().equals("gf");
	}

	// TODO Share a single process for the whole build cycle to save on overheads
	private void buildFile(IFile file) {
		/* 
		 * We want to compile each source file in .gf with roughly these commands:
		 * i --retain HelloEng.gf
		 * ss -strip -save
		 * 
		 * Shell command: echo "ss -strip -save" | gf -retain HelloEng.gf
		 */
		String filename = file.getName();
		String buildDir = file.getRawLocation().removeLastSegments(1).toOSString() + java.io.File.separator + BUILD_FOLDER;

		ArrayList<String> command = new ArrayList<String>();
		command.add(gfPath);
		command.add("--retain");
		command.add(".." + java.io.File.separator + filename);

		try {
			// Check the build directory and try to create it
			File buildDirFile = new File(buildDir);
			if (!buildDirFile.exists()) {
				buildDirFile.mkdir();
			}

			// Piece together our GF process
			ProcessBuilder b = new ProcessBuilder(command);
			b.directory(buildDirFile);
			b.redirectErrorStream(true);
			Process process = b.start();
			
			// Feed it our commands, then quit
			BufferedWriter processInput = new BufferedWriter(new OutputStreamWriter(process.getOutputStream()));
			processInput.write("ss -strip -save");
			processInput.newLine();
			processInput.flush();
			processInput.write("quit");
			processInput.newLine();
			processInput.flush();
			
//			BufferedReader processOutput = new BufferedReader(new InputStreamReader(process.getInputStream()));
//			String ls_str;
//			while ((ls_str = processOutput.readLine()) != null) {
//				System.out.println(ls_str);
//			}

			// Tidy up
			processInput.close();
//			processOutput.close();
			process.waitFor();
			
		} catch (IOException e) {
			// TODO Some informative errors here on the console?
			e.printStackTrace();
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		
	}
	
}
