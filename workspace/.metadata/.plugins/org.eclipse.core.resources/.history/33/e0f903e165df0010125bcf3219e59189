package org.grammaticalframework.eclipse.naming;

import java.util.Collections;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.ENamedElement;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.xtext.naming.IQualifiedNameConverter;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.naming.IQualifiedNameProvider;
import org.eclipse.xtext.util.IResourceScopeCache;
import org.eclipse.xtext.util.PolymorphicDispatcher;
import org.eclipse.xtext.util.SimpleAttributeResolver;
import org.eclipse.xtext.util.Strings;
import org.eclipse.xtext.util.Tuples;
import org.grammaticalframework.eclipse.gF.*;

import com.google.common.base.Function;
import com.google.inject.Inject;
import com.google.inject.Provider;

//import org.grammaticalframework.eclipse.gF.Grammar;

/**
 * Custom name provider for GF
 * 
 * These are the types which we would want to export through the GlobalScopeProvider (and therefore the types
 * that types that should have a valid qualified name):
 * 
 * - Def, CatDef, FunDef, DataDef, DataConst, ParDef, ParConst (Qualified by
 * module name)
 * - ModType (just the simple name)
 * 
 * Everything else we DO NOT want to export, and thus should not provide a
 * qualified name for itself.
 * 
 * @author John J. Camilleri
 */

/*
 * This is based on the SimpleNamingProvider implementation
 * 
public class GFQualifiedNameProvider extends
		IQualifiedNameProvider.AbstractImpl {

	@Inject
	private IQualifiedNameConverter qualifiedNameConverter;

	public QualifiedName getFullyQualifiedName(EObject obj) {

		String name = SimpleAttributeResolver.NAME_RESOLVER.apply(obj);
		if (name == null)
			return null;
		return qualifiedNameConverter.toQualifiedName(name);
	}
}
*/

/**
 * Based on the DefaultDeclarativeQualifiedNameProvider implementation
 * 
 * @author John J. Camilleri
 *
 */
//public class GFQualifiedNameProvider extends DefaultDeclarativeQualifiedNameProvider {
public class GFQualifiedNameProvider extends IQualifiedNameProvider.AbstractImpl {
	
	private PolymorphicDispatcher<QualifiedName> qualifiedName = new PolymorphicDispatcher<QualifiedName>("qualifiedName",1,1,Collections.singletonList(this), PolymorphicDispatcher.NullErrorHandler.<QualifiedName>get())
	{
		@Override
		protected QualifiedName handleNoSuchMethod(Object... params) { 
			return null;
		}
	};
	
	@Inject
	private IQualifiedNameConverter converter = new IQualifiedNameConverter.DefaultImpl();
	
	protected IQualifiedNameConverter getConverter() {
		return converter;
	}
	
	@Inject
	private IResourceScopeCache cache = IResourceScopeCache.NullImpl.INSTANCE;
	
	private Function<EObject, String> nameResolver = SimpleAttributeResolver.newResolver(String.class, "name");

//	protected Function<EObject, String> getNameResolver() {
//		return nameResolver;
//	}
	
	/**
	 * Get name from either direct or nested "name" attribute
	 * @param ele
	 * @return
	 */
	private String getNameNested(EObject ele) {
		
		EStructuralFeature y = ele.eClass().getEStructuralFeature("name");
		
		// If String then return
		if (y.getEType().getInstanceClass()==String.class)
			return nameResolver.apply(ele);
		
		// If Name then get Name.name
		if (y.getEType().getInstanceClass()==Name.class) {
			return ((Name)y).getName();
		}

		// If ListName...
		if (y.getEType().getInstanceClass()==ListName.class) {
			// If size = 1 then first
			// If size > 1 then return as separate qualified names?
			return ((ListName)y).getName().get(0).getName();
		}
		
		if (y.getEType().getInstanceClass()==ListIdent.class) {
			// If size = 1 then first
			// If size > 1 then return as separate qualified names?
//			return ((ListIdent)y).getName().get(0);
			return ((FunDef)ele).getName().getName().get(0).toString();
		}
		
		return "FAIL";
	}
	
	/**
	 * Don't qualify modules, just return their simple name
	 * 
	 */
	String qualifiedName(ModType ele) {
		return ele.getName();
	}
	
	/**
	 * Qualify top level defs with their parent module name
	 * 
	 */
	private String qualifyWithModuleName(EObject ele) {
		//Climb tree until we find ModDef, then grab the module name
		EObject temp = ele;
		while (!temp.eClass().getName().equals("ModDef") && temp.eContainer() != null) {
			temp = temp.eContainer();
		}
		String qualifiedName = (temp.eContainer() != null)
			? ((ModDef)temp).getType().getName() + "." + getNameNested(ele)
//			: getNameResolver().apply(ele);
			: null;
		return qualifiedName;
	}
	
	String qualifiedName(Def ele) {
		return qualifyWithModuleName(ele);
	};
	String qualifiedName(CatDef ele) {
		return qualifyWithModuleName(ele);
	};
	String qualifiedName(FunDef ele) {
		return qualifyWithModuleName(ele);
	};
	String qualifiedName(DataDef ele) {
		return qualifyWithModuleName(ele);
	};
	String qualifiedName(DataConstr ele) {
		return qualifyWithModuleName(ele);
	};
	String qualifiedName(ParDef ele) {
		return qualifyWithModuleName(ele);
	};
	String qualifiedName(ParConstr ele) {
		return qualifyWithModuleName(ele);
	};
	
	/**
	 * Our primary dispatching function
	 */
	public QualifiedName getFullyQualifiedName(final EObject eObj) {
		return cache.get(Tuples.pair(eObj, "fqn"), eObj.eResource(), new Provider<QualifiedName>(){

			public QualifiedName get() {
				// See if our methods up above will name it...
				Object qualifiedNameFromDispatcher = qualifiedName.invoke(eObj);
				if (qualifiedNameFromDispatcher!=null) {
					System.out.println("I just qualified: " + eObj.eClass().getName() + " -> " + qualifiedNameFromDispatcher);	
					return converter.toQualifiedName((String) qualifiedNameFromDispatcher);
				} else {
					// ...anything else shouldn't get a qualified name
					return null;
				}
			}
		});
	}	
	
}
