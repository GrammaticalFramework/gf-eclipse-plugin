/**
 * GF grammar based on the GF Book (2011), Appendix C.6
 * 
 * Some (hopefully syntactically-equivalent) modifications have been made to please ANTLR.
 * 
 * This grammar basically treats a single resource (file), which is why we start directly
 * from ModDef and exclude the rules ListModDef, Grammar.
 */

grammar org.grammaticalframework.eclipse.GF
	hidden(WS, ML_COMMENT, SL_COMMENT, COMPILER_PRAGMA)
	
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
	
generate gF "http://www.grammaticalframework.org/eclipse/GF"

/*
Grammar :
	ListModDef
;

ListModDef :
	{ListModDef} (modules+=ModDef)*
;
*/

ModDef :
	(incomplete?='incomplete')? type=ModType '=' body=ModBody (';')*
;

// Cross-ref checking is done by Validation, not via grammar
ModType :
		abstract?='abstract'	name=Ident
	|	resource?='resource'	name=Ident
	|	interface?='interface'	name=Ident
	|	concrete?='concrete'	name=Ident 'of' abstractName=Ident
	|	instance?='instance'	name=Ident 'of' abstractName=Ident
;

ModBody :
    {ModBody} ( (extends+=Included (',' extends+=Included)*)? '**')? ('open' (opens+=Open (',' opens+=Open)*)? 'in')? '{' (judgements+=TopDef)* '}'
	| {ModBody} (extends+=Included (',' extends+=Included)*)?
	| {ModBody} functor=Included functorInstantiation?='with' (instantiations+=Open (',' instantiations+=Open)*)?
	| {ModBody} functor=Included functorInstantiation?='with' (instantiations+=Open (',' instantiations+=Open)*)? '**' ('open' (opens+=Open (',' opens+=Open)*)? 'in')? '{' (judgements+=TopDef)* '}'
	| {ModBody} (extends+=Included (',' extends+=Included)*)? '**' functor=Included functorInstantiation?='with' (instantiations+=Open (',' instantiations+=Open)*)?
	| {ModBody} (extends+=Included (',' extends+=Included)*)? '**' functor=Included functorInstantiation?='with' (instantiations+=Open (',' instantiations+=Open)*)? '**' ('open' (opens+=Open (',' opens+=Open)*)? 'in')? '{' (judgements+=TopDef)* '}'
;

Open :
	      name=Ident
	| '(' name=Ident ')'
	| '(' alias=Ident '=' name=Ident ')'
;

Included :
	  name=Ident
	| name=Ident inclusive?=	'[' includes+=Ident (',' includes+=Ident)* ']'
	| name=Ident exclusive?='-' '[' excludes+=Ident (',' excludes+=Ident)* ']'
;

Def :
//	  name=ListName '=' definition=Exp
//	| name=Name patterns=ListPatt '=' definition=Exp
//	| name=ListName ':' type=Exp ('=' definition=Exp)?
	  name+=Name (',' name+=Name)*				 '=' definition=Exp
	| name+=Name (',' name+=Name)* ':' type=Exp ('=' definition=Exp)?
	| name+=Name patterns=ListPatt				 '=' definition=Exp
;

// For handling the overload syntax
OperDef returns Def :
	  name+=Name (',' name+=Name)*				 '=' ( definition=Exp | overload?='overload' '{' overloads+=Def (';' overloads+=Def ';'? )* '}')
	| name+=Name (',' name+=Name)* ':' type=Exp	('=' ( definition=Exp | overload?='overload' '{' overloads+=Def (';' overloads+=Def ';'? )* '}'))?
	| name+=Name patterns=ListPatt				 '=' definition=Exp
;

TopDef :
	  cat?='cat'		(definitions+=CatDef ';')+
	| fun?='fun'		(definitions+=FunDef ';')+
	| data?='data'		(definitions+=FunDef ';')+
	| def?='def'		(definitions+=Def ';')+
	| data?='data'		(definitions+=DataDef ';')+
	| param?='param'	(definitions+=ParDef ';')+		
//	| oper?='oper'		(definitions+=Def ';')+
	| oper?='oper'		(definitions+=OperDef ';')+
	| lincat?='lincat'	(definitions+=PrintDef ';')+
	| lindef?='lindef'	(definitions+=Def ';')+
	| lin?='lin'		(definitions+=Def ';')+
	| printname?='printname' 'cat'	(definitions+=PrintDef ';')+
	| printname?='printname' 'fun'	(definitions+=PrintDef ';')+
	| flags?='flags'	(definitions+=FlagDef ';')+
;

CatDef :
	      name=Ident context+=DDecl*
	| '[' name=Ident context+=DDecl* ']' ('{' size=Integer '}')?
;

FunDef :
	name+=Ident (',' name+=Ident)* ':' type=Exp
;

DataDef :
	name=Ident '=' (constructors+=DataConstr ('|' constructors+=DataConstr)* '|'? )?
;

DataConstr :
	  name=Ident
	| module=Ident '.' name=Ident
;

ParDef :
	  name=Ident '=' (constructors+=ParConstr ('|' constructors+=ParConstr)* '|'? )?
	| name=Ident '=' '(' 'in' id2=Ident ')'
	| name=Ident
;

ParConstr :
	name=Ident constructors+=DDecl*
;

PrintDef :
//	name=ListName '=' printname=Exp
	name+=Name (',' name+=Name)* '=' printname=Exp
;

FlagDef :
	  name=Ident '=' (value=Ident | String)
;

Name :
	name=Ident
	| '[' name=Ident ']'
;

LocDef :
	  name+=Ident (',' name+=Ident)* ':' type=Exp 	('=' value=Exp)?
	| name+=Ident (',' name+=Ident)*				 '=' value=Exp
;

ListLocDef :
	// ε | LocDef | LocDef ';' ListLocDef
	{ListLocDef} ( localDefinitions+=LocDef (';' localDefinitions+=LocDef)* ';'? )?
;

Exp6 :
//	  {Exp6} Ident
	  name=[Ident|ID]		// constant or variable
	  
	| sort?=Sort			// type of types/param types/strings/token lists
	| string?=String			// string literal
	| integer?=Integer		// integer literal
	| double?=Double			// floating point literal

//	| {Exp6} '?' Integer
//	| {Exp6} '?'
	| meta?='?' (=>Integer)?		// metavariable

	| emptyString?='[' ']'		// empty token list
	| data?='data'			
	
//	| '[' Ident es=Exps ']'
	| listCat?='[' category=[Ident|ID] list=Exps ']'		// list category
	
	| tokenList?='[' String ']'						// token list
	| record?='{' defList=ListLocDef '}'				// record / record type

//	| '<' ltc=ListTupleComp '>'
//	| '<' e+=Exp ':' e+=Exp '>'
	| tuple?='<' (=> tupleList=ListTupleComp | v=Exp ':' type=Exp) '>'		// tuple | type-annotated expression

	| identity?='(' v=Exp ')'
;

Exp5 :
	// Exp5 . Label | Exp6
	  v=Exp6 ('.' label+=Label)*		// projection or qualification
;

Exp4 :
//	  e1=Exp4 e2=Exp5		// function application
	  'table' '{' caseList=ListCase '}'				(args+=Exp5)*
	  
//	| 'table' e+=Exp6 '{' lc=ListCase '}'		(e+=Exp5)*
//	| 'table' e+=Exp6 '[' le=ListExp ']'		(e+=Exp5)*
	| 'table' argType=Exp6 ( '{' caseList=ListCase '}' | '[' expList=ListExp ']' )		(args+=Exp5)*			// course-of-values table
	
	| 'case' caseOf=Exp 'of' '{' caseList=ListCase '}'	(args+=Exp5)*
	| 'variants' '{' expList=ListExp '}'			(args+=Exp5)*
	| 'pre' '{' caseList=ListCase '}'				(args+=Exp5)*
	| 'lincat' name=[Ident|ID]						(args+=Exp5)*
	| 'lin' name=[Ident|ID] inner=Exp6				(args+=Exp5)*
	| v=Exp5										(args+=Exp5)*
;

Exp3 :
//	  e1=Exp3 '!' e2=Exp4
//	| e1=Exp3 '*' e2=Exp4
//	| e1=Exp3 '**' e2=Exp4
//	| '#' Patt2
//	| Exp4
	  		v=Exp4		(('!'|'*'|'**') e+=Exp4)*
	| '#'	v=Patt2		(('!'|'*'|'**') e+=Exp4)*
;

Exp2 :
//	  e1=Exp3 '+' e2=Exp2
//	| Exp3
	  v=Exp3 ('+' e+=Exp2)?
;

Exp1 :
//	  e1=Exp2 '++' e2=Exp1
//	| Exp2
	  v=Exp2 ('++' e+=Exp1)?
;

Exp :
	 '\\' bindList=ListBind '->' v=Exp					(=> '|' e+=Exp1)*
	| '\\' '\\' bindList=ListBind '=>' v=Exp				(=> '|' e+=Exp1)*
//-	| d+=Decl '->' e+=Exp							(=> '|' e+=Exp1)*
//-	| e+=Exp3 '=>' e+=Exp							(=> '|' e+=Exp1)*
	| 'let' '{' defList=ListLocDef '}' 'in' v=Exp		(=> '|' e+=Exp1)*
	| 'let' defList=ListLocDef 'in' v=Exp				(=> '|' e+=Exp1)*
//-	| e+=Exp3 'where' '{' e+=ListLocDef '}'			(=> '|' e+=Exp1)*

 /*
 * The following is (hopefully) an amalgamation of:
 *	Decl -> Exp
 *  Exp3 => Exp
 * 	Exp3 where { ListLocDef }
 * 	Exp1
 */
	| '(' bindList=ListBind ':' type=Exp ')'	'->' v=Exp		(=> '|' e+=Exp1)*
	| v=Exp4
		(
			(('!'|'*'|'**') e+=Exp4)*				// That makes Exp3
			(
				  '=>' e+=Exp
				| 'where' '{' defList=ListLocDef '}'
				| ('+' e+=Exp2)? ('++' e+=Exp1)?
			)

			| '->' e+=Exp
		)
		(=> '|' e+=Exp1)*
		
	| '#' v=Patt2
		(('!'|'*'|'**') e+=Exp4)*				// That makes Exp3
		(
			  '=>' e+=Exp
			| 'where' '{' defList=ListLocDef '}'
			| ('+' e+=Exp2)? ('++' e+=Exp1)?
		)
		(=> '|' e+=Exp1)*

/*
 * The following is an amalgamation of:
 *  Exp3 => Exp
 * 	Exp3 where { ListLocDef }
 * 	Exp1
 *
	| e+=Exp3
		(
			  '=>' e+=Exp
			| 'where' '{' e+=ListLocDef '}'
			| ('+' e+=Exp2)? ('++' e+=Exp1)?
		)
		(=> '|' e+=Exp1)*

*/

//-	| e+=Exp '|' e+=Exp1
//-	| e+=Exp1										(=> '|' e+=Exp1)*
 
;

ListExp :
	// ε | Exp | Exp ';' ListExp
	{ListExp} ( expressions+=Exp (';' expressions+=Exp)* ';'? )?
;

Exps :
	// ε | Exp6 Exps
	{Exps} (expressions+=Exp6)*
;

Patt2 :
	  {Patt2} '_'
	| {Patt2} name=Ident
	| {Patt2} name=Ident '.' label=Ident
	| {Patt2} Integer
	| {Patt2} Double
	| {Patt2} String
	| '{' ListPattAss '}'
	| '<' ListPattTupleComp '>'
	| {Patt2} '#' name=Ident
	| {Patt2} '?'
	| '(' Patt ')'
;

Patt1 :
	  name=Ident value=ListPatt
	| name=Ident '.' label=Ident value=ListPatt
//	| Patt2 '*'
	| name=Ident '@' value=Patt2
	| '-' Patt2
	| Patt2 ('*')?
//	| Patt2
;

Patt :
	// Patt '|' Patt1 | Patt '+' Patt1 | Patt1
	p += Patt1 (('|'|'+') p += Patt1)*
;

// "Pattern Assignment"
PattAss :
	name+=Ident (',' name+=Ident)* '=' value=Patt
;

Label :
	  name=Ident
	| '$' index=Integer
;

Sort :
	  'Type'
	| 'PType'
	| 'Str'
	| 'Strs'
;

ListPattAss :
	// ε | PattAss | PattAss ';' ListPattAss
	{ListPattAss} ( assignments+=PattAss (';' assignments+=PattAss)* ';'? )?
;

// WARNING If you refactor this, make sure to update GFScopeProvider::getAllDescriptions(), line 137
ListPatt :
	// Patt2 | Patt2 ListPatt
	(patterns += Patt2)+
;

Bind :
	  name=Ident
	| {Bind} '_'
;

// WARNING If you refactor this, make sure to update GFScopeProvider::getAllDescriptions(), line 142
ListBind :
	// ε | Bind | Bind ',' ListBind
	{ListBind} ( bindings+=Bind (',' bindings+=Bind)* )?
;

/*
 * This has now been melted down into Exp
 */ 
//Decl :
//	  '(' lb=ListBind ':' e+=Exp ')'
//	| e+=Exp4
//;
 
TupleComp :
	Exp
;

PattTupleComp :
	Patt
;

ListTupleComp :
	// ε | TupleComp | TupleComp ',' ListTupleComp
	{ListTupleComp} ( l += TupleComp (',' l += TupleComp)* )?
;

ListPattTupleComp :
	// ε | PattTupleComp | PattTupleComp ',' ListPattTupleComp
	{ListPattTupleComp} ( l += PattTupleComp (',' l += PattTupleComp)* )?
;

Case :
	pattern=Patt '=>' e=Exp
;

ListCase :
	// Case | Case ';' ListCase
	cases+=Case (';' cases+=Case)*
;

DDecl :
	  '(' bindList=ListBind ':' e=Exp ')'
	| Exp6
;

/*
 * Terminals, Comments
 * 
 * Based on (but modified from) those from org.eclipse.xtext.common.Terminals
 * Ref: http://www.eclipse.org/Xtext/documentation/2_0_0/020-grammar-language.php#grammarLanguage_6
 */
Ident : s=ID ; 
 
terminal ID : 
	('a'..'z'|'A'..'Z'|'_')('a'..'z'|'A'..'Z'|'0'..'9'|'_'|'\'')*
//	('a'..'z'|'A'..'Z'|'_')('a'..'z'|'A'..'Z'|'0'..'9'|'_'|'\'')*('.'('a'..'z'|'A'..'Z'|'_')('a'..'z'|'A'..'Z'|'0'..'9'|'_'|'\'')*)?
;
terminal String : 
	  '"' ( '\\'('"'|'\\') | !('\\'|'"') )* '"'
; 
terminal Integer returns ecore::EInt: 
	('0'..'9')+
;
terminal Double returns ecore::EDouble :
	('0'..'9')+'.'('0'..'9')+('e''-'?('0'..'9')+)?
;
terminal COMPILER_PRAGMA :
	'--#' !('\n'|'\r')* ('\r'? '\n')?
;
terminal ML_COMMENT :
	'{-' -> '-}'
;
terminal SL_COMMENT : 
	'--' !('\n'|'\r')* ('\r'? '\n')?
;
terminal WS : 
	(' '|'\t'|'\r'|'\n')+
;
terminal ANY_OTHER : 
	.
;
