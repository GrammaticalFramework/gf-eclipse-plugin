/**
 * GF Eclipse Plugin
 * http://www.grammaticalframework.org/eclipse/
 * John J. Camilleri, 2012
 * 
 * The research leading to these results has received funding from the
 * European Union's Seventh Framework Programme (FP7/2007-2013) under
 * grant agreement no FP7-ICT-247914.
 */
 
/**
 * GF grammar based on the GF Book (2011), Appendix C.6
 * Some (hopefully syntactically-equivalent) modifications have been made to please the compiler.
 */
grammar org.grammaticalframework.eclipse.GF

hidden(WS, ML_COMMENT, SL_COMMENT, COMPILER_PRAGMA, GF_DOC)
	
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
	
generate gF "http://www.grammaticalframework.org/eclipse/GF"

/*
 * This grammar basically treats a single resource (file), which is why we start directly
 * from ModDef and exclude the rules ListModDef, Grammar.

Grammar :
	ListModDef
;

ListModDef :
	{ListModDef} (modules+=ModDef)*
;
*/

ModDef :
	(incomplete?='incomplete')? type=ModType '=' body=ModBody (';')*
;

// Cross-ref checking is done by Validation, not via grammar
ModType :
		abstract?='abstract'	name=Ident
	|	resource?='resource'	name=Ident
	|	interface?='interface'	name=Ident
	|	concrete?='concrete'	name=Ident 'of' abstractName=Ident
	|	instance?='instance'	name=Ident 'of' abstractName=Included
;

ModBody :
    {ModBody} ( (extends+=Included (',' extends+=Included)*)? '**')? content=ModContent
	| {ModBody} (extends+=Included (',' extends+=Included)*)?
	| {ModBody} functor=Included functorInstantiation?='with' (instantiations+=Inst (',' instantiations+=Inst)*)?
	| {ModBody} functor=Included functorInstantiation?='with' (instantiations+=Inst (',' instantiations+=Inst)*)? '**' content=ModContent
	| {ModBody} (extends+=Included (',' extends+=Included)*)? '**' functor=Included functorInstantiation?='with' (instantiations+=Inst (',' instantiations+=Inst)*)?
	| {ModBody} (extends+=Included (',' extends+=Included)*)? '**' functor=Included functorInstantiation?='with' (instantiations+=Inst (',' instantiations+=Inst)*)? '**' content=ModContent
;

ModContent :
	{ModContent} ('open' (opens+=Open (',' opens+=Open)*)? 'in')? '{' (judgements+=TopDef)* '}'
;

Open :
	      name=Ident
	| '(' alias=Ident '=' name=Ident ')'
;

Inst :
	  '(' interface=Ident '=' name=Ident ')'
;

Included :
	  name=Ident
	| name=Ident inclusive?=	'[' includes+=Ident (',' includes+=Ident)* ']'
	| name=Ident exclusive?='-' '[' excludes+=Ident (',' excludes+=Ident)* ']'
;

TopDef :
	  cat?='cat'		(definitions+=CatDef ';')+
	| fun?='fun'		(definitions+=FunDef ';')+
	| def?='def'		(definitions+=DefDef ';')+
	| data?='data'		(definitions+=DataDef ';')+
	| param?='param'	(definitions+=ParamDef ';')+		
	| oper?='oper'		(definitions+=OperDef ';')+
	| lincat?='lincat'	(definitions+=TermDef ';')+
	| lindef?='lindef'	(definitions+=TermDef ';')+
	| lin?='lin'		(definitions+=LinDef ';')+
	| printname?='printname' 'cat'	(definitions+=TermDef ';')+
	| printname?='printname' 'fun'	(definitions+=TermDef ';')+
	| flags?='flags'	(definitions+=FlagDef ';')+
;

CatDef :
	      name=Ident context+=DDecl*
	| '[' name=Ident context+=DDecl* ']' ('{' size=Integer '}')?
;

FunDef :
	  name+=Ident (',' name+=Ident)* ':' type=Exp
;

DefDef :
	  name+=Name (',' name+=Name)*				 '=' definition=Exp
	| name+=Name patterns=ListPatt				 '=' definition=Exp
;

DataDef :
	  name+=Ident '=' constructors+=Ident ('|' constructors+=Ident)*
	| name+=Ident (',' name+=Ident)* ':' type=Exp
;

ParamDef :
	  name=Ident ('=' constructors+=ParConstr ('|' constructors+=ParConstr)* '|'? )?
;

// For handling the overload syntax
//OperDef :
//	  name+=Name (',' name+=Name)*				 '=' ( definition=Exp | overload?='overload' '{' overloads+=DefDef (';' overloads+=DefDef )* ';'? '}')
//	| name+=Name (',' name+=Name)* ':' type=Exp	('=' ( definition=Exp | overload?='overload' '{' overloads+=DefDef (';' overloads+=DefDef )* ';'? '}'))?
//	| name+=Name (',' name+=Name)* ':' overload?='overload'	'{' overloads+=DefDef (';' overloads+=DefDef )* ';'? '}'
//	| name+=Name patterns=ListPatt				 '=' definition=Exp
//;
OperDef :
	  name+=Name (',' name+=Name)* ':' type=Exp	('=' ( definition=Exp | overload?='overload' '{' overloads+=DefDef (';' overloads+=DefDef )* ';'? '}'))?
	| name+=Name (',' name+=Name)*				 '=' ( definition=Exp | overload?='overload' '{' overloads+=DefDef (';' overloads+=DefDef )* ';'? '}')
	| name+=Name (args+=Arg)+					 '=' definition=Exp
;

LinDef:
	  name+=Name (',' name+=Name)*	'=' definition=Exp
	| name+=Name (args+=Arg)+		'=' definition=Exp
;

TermDef:
	  name+=Name (',' name+=Name)*	'=' definition=Exp
;

FlagDef :
	  name=Ident '=' (value=Ident | String)
;

ParConstr :
	name=Ident constructors+=DDecl*
;

Name :
	name=Ident
	| '[' name=Ident ']'
;

LocDef :
	  name+=Ident (',' name+=Ident)* ':' type=Exp 	('=' value=Exp)?
	| name+=Ident (',' name+=Ident)*				 '=' value=Exp
;

ListLocDef :
	// ε | LocDef | LocDef ';' ListLocDef
	{ListLocDef} ( localDefinitions+=LocDef (';' localDefinitions+=LocDef)* ';'? )?
;

/*
Exp
  : Exp1 '|' Exp 
  | '\\'   ListBind '->' Exp
  | '\\\\' ListBind '=>' Exp
  | Decl '->' Exp
  | Exp3 '=>' Exp
  | 'let' '{' ListLocDef '}' 'in' Exp
  | 'let' ListLocDef 'in' Exp
  | Exp3 'where' '{' ListLocDef '}'
  | 'in' Exp5 String
  | Exp1   
*/
Exp :
	 '\\' bindList=ListBind '->' v=Exp				(=> '|' e+=Exp1)*
	| '\\' '\\' bindList=ListBind '=>' v=Exp		(=> '|' e+=Exp1)*
//-	| d+=Decl '->' e+=Exp							(=> '|' e+=Exp1)*
//-	| e+=Exp3 '=>' e+=Exp							(=> '|' e+=Exp1)*
	| 'let' '{' defList=ListLocDef '}' 'in' v=Exp	(=> '|' e+=Exp1)*
	| 'let' defList=ListLocDef 'in' v=Exp			(=> '|' e+=Exp1)*
	| 'in' Exp5 String								(=> '|' e+=Exp1)*
//-	| e+=Exp3 'where' '{' e+=ListLocDef '}'			(=> '|' e+=Exp1)*

 /*
 * The following is (hopefully) an amalgamation of:
 *	Decl -> Exp
 *  Exp3 => Exp
 * 	Exp3 where { ListLocDef }
 * 	Exp1
 */
	| '(' bindList=ListBind ':' type=Exp ')'	'->' v=Exp		(=> '|' e+=Exp1)*
	| v=Exp4
		(
			(('!'|'*'|'**') e+=Exp4)*				// That makes Exp3
			(
				  '=>' e+=Exp
				| 'where' '{' defList=ListLocDef '}'
				| ('+' e+=Exp2)? ('++' e+=Exp1)?
			)

			| '->' e+=Exp
		)
		(=> '|' e+=Exp1)*
		
	| '#' v=Patt2
		(('!'|'*'|'**') e+=Exp4)*				// That makes Exp3
		(
			  '=>' e+=Exp
			| 'where' '{' defList=ListLocDef '}'
			| ('+' e+=Exp2)? ('++' e+=Exp1)?
		)
		(=> '|' e+=Exp1)*
 
;

Exp1 returns Exp :
	Exp2 ('++' e+=Exp1)*
;

Exp2 returns Exp :
	Exp3 ('+' e+=Exp2)*
;

/*
Exp3
  : Exp3 '!' Exp4 
  | 'table' '{' ListCase '}'
  | 'table' Exp6 '{' ListCase '}'
  | 'table' Exp6 '[' ListExp ']'
  | Exp3 '*'  Exp4
  | Exp3 '**' Exp4
  | Exp4
*/
Exp3 returns Exp :
	  Exp4											(('!'|'*'|'**') e+=Exp4)*
	| 'table' '{' caseList=ListCase '}'				(('!'|'*'|'**') e+=Exp4)*
	| 'table' argType=Exp6 ( '{' caseList=ListCase '}' | '[' expList=ListExp ']' )		(('!'|'*'|'**') e+=Exp4)*			// course-of-values table
;

/*
Exp4
  : Exp4 Exp5
  | Exp4 '{' Exp '}' 
  | 'case' Exp 'of' '{' ListCase '}'
  | 'variants' '{' ListExp '}'
  | 'pre' '{' ListCase '}'
  | 'pre' '{' String ';' ListAltern '}'
  | 'pre' '{' Ident ';' ListAltern '}'
  | 'strs' '{' ListExp '}'
  | '#' Patt3
  | 'pattern' Exp5
  | 'lincat' Ident Exp5
  | 'lin' Ident Exp5
  | Exp5
*/
Exp4 returns Exp :
	  'case' caseOf=Exp 'of' '{' caseList=ListCase '}'	(e+=Exp5 | '{'e+=Exp'}')*
	| 'variants' '{' expList=ListExp '}'				(e+=Exp5 | '{'e+=Exp'}')*
	| 'pre' '{' caseList=ListCase '}'					(e+=Exp5 | '{'e+=Exp'}')*
	| 'pre' '{' String ';' alts+=Altern (';' alts+=Altern)* '}'		(e+=Exp5 | '{'e+=Exp'}')*
	| 'pre' '{' Ident  ';' alts+=Altern (';' alts+=Altern)* '}'		(e+=Exp5 | '{'e+=Exp'}')*
	| 'strs' '{' expList=ListExp '}'					(e+=Exp5 | '{'e+=Exp'}')*
	| '#' pattern=Patt3									(e+=Exp5 | '{'e+=Exp'}')*
	| 'pattern' pattern=Exp5							(e+=Exp5 | '{'e+=Exp'}')*
	| 'lincat' name=[Ident|ID] inner=Exp5				(e+=Exp5 | '{'e+=Exp'}')*
	| 'lin' name=[Ident|ID] inner=Exp5					(e+=Exp5 | '{'e+=Exp'}')*
	| Exp5												(e+=Exp5 | '{'e+=Exp'}')*
;

Exp5 returns Exp :
	Exp6 ('.' label+=Label)*		// projection or qualification
;

/*
Exp6 
  : Ident 
  | Sort
  | String
  | Integer
  | Double
  | '?'
  | '[' ']'
  | '[' Ident Exps ']'
  | '[' String ']'
  | '{' ListLocDef '}'
  | '<' ListTupleComp '>'
  | '<' Exp ':' Exp '>'
  | LString
  | '(' Exp ')'
*/
Exp6 returns Exp :
	  name=[Ident|ID]		// constant or variable
	| sort?=Sort			// type of types/param types/strings/token lists
	| string?=String			// string literal
	| integer?=Integer		// integer literal
	| double?=Double			// floating point literal
	| meta?='?' 		// metavariable
	| emptyString?='[' ']'		// empty token list
	| listCat?='[' category=[Ident|ID] list=Exps ']'		// list category
	| tokenList?='[' String ']'						// token list
	| record?='{' defList=ListLocDef '}'				// record / record type
	| tuple?='<' (=> tupleList=ListTupleComp | v=Exp ':' type=Exp) '>'		// tuple | type-annotated expression
//  | LString
	| identity?='(' v=Exp ')'
;

ListExp :
	// ε | Exp | Exp ';' ListExp
	{ListExp} ( expressions+=Exp (';' expressions+=Exp)* ';'? )?
;

Exps :
	// ε | Exp6 Exps
	{Exps} (expressions+=Exp6)*
;

Patt :
	// Patt '|' Patt1 | Patt '+' Patt1 | Patt1
	p += Patt1 (('|'|'+') p += Patt1)*
;

Patt1 returns Patt :
	  name=Ident value=ListPatt
	| name=Ident '.' label=Ident value=ListPatt
	| Patt3 '*'
	| Patt2
;

Patt2 returns Patt :
	  name=Ident '@' value=Patt3
	| '-' Patt3
	| '~' Exp6
	| Patt3
;

Patt3 returns Patt :
	  '?'
	| '[' String ']'
	| '#' name=Ident
	| '#' name=Ident '.' label=Ident
	| '_'
	| name=Ident
	| name=Ident '.' label=Ident
	| Integer
	| Double
	| String
	| '{' ListPattAss '}'
	| '<' ListPattTupleComp '>'
	| '(' Patt ')'
;

// "Pattern Assignment"
PattAss :
	  name+=Ident (',' name+=Ident)* '=' value=Patt
;

Label :
	  name=Ident
	| '$' index=Integer
;

Sort :
	  'Type'
	| 'PType'
	| 'Tok'
	| 'Str'
	| 'Strs'
;

//BuiltInCat :
//	  'String'
//	| 'Int'
//	| 'Ints'
//	| 'Float'
//;

ListPattAss :
	// ε | PattAss | PattAss ';' ListPattAss
	{ListPattAss} ( assignments+=PattAss (';' assignments+=PattAss)* ';'? )?
;

// WARNING If you refactor this, make sure to update GFScopeProvider::getAllDescriptions(), line 137
ListPatt :
	(patterns += PattArg)+
;

PattArg returns Patt:
	  Patt2
	| '{' Patt '}'
;

Arg :
	  name+=Ident
	| {Arg} '_'
	| '{' (name+=Ident)+ '}' // ListIdent2
;

Bind :
	  name+=Ident
	| {Bind} '_'
	| '{' name+=Ident (',' name+=Ident)* '}' // ListIdent
;

// WARNING If you refactor this, make sure to update GFScopeProvider::getAllDescriptions(), line 142
ListBind :
	{ListBind} bindings+=Bind (',' bindings+=Bind)*
;

/*
 * This has now been melted down into Exp
 */ 
Decl :
	  '(' bindings+=Bind (',' bindings+=Bind)* ':' e=Exp ')'
	| e=Exp3
;

ListTupleComp :
	{ListTupleComp} ( elements+=Exp (',' elements+=Exp)* ','? )?
;

ListPattTupleComp :
	{ListPattTupleComp} ( patterns+=Patt (',' patterns+=Patt)* ','? )?
;

Case :
	pattern=Patt '=>' e=Exp
;

ListCase :
	// Case | Case ';' ListCase
	cases+=Case (';' cases+=Case)*
;

Altern :
	alt1=Exp '/' alt2=Exp
;

DDecl :
	  '(' bindList=ListBind ':' e=Exp ')'
	| Exp6
;

/*
 * Terminals, Comments
 * 
 * Based on (but modified from) those from org.eclipse.xtext.common.Terminals
 * Ref: http://www.eclipse.org/Xtext/documentation/2_0_0/020-grammar-language.php#grammarLanguage_6
 */
Ident : s=ID ; 
 
terminal ID : 
	('a'..'z'|'A'..'Z'|'_')('a'..'z'|'A'..'Z'|'0'..'9'|'_'|'\'')*
//	('a'..'z'|'A'..'Z'|'_')('a'..'z'|'A'..'Z'|'0'..'9'|'_'|'\'')*('.'('a'..'z'|'A'..'Z'|'_')('a'..'z'|'A'..'Z'|'0'..'9'|'_'|'\'')*)?
;
terminal String : 
	  '"' ( '\\'('"'|'\\') | !('\\'|'"') )* '"'
; 
terminal Integer returns ecore::EInt: 
	('0'..'9')+
;
terminal Double returns ecore::EDouble :
	('0'..'9')+'.'('0'..'9')+('e''-'?('0'..'9')+)?
;
terminal COMPILER_PRAGMA :
	'--#' !('\n'|'\r')* ('\r'? '\n')?
;
terminal GF_DOC :
	('--%'|'--:') !('\n'|'\r')* ('\r'? '\n')?
;
terminal ML_COMMENT :
	'{-' -> '-}'
;
terminal SL_COMMENT : 
	'--' !('\n'|'\r')* ('\r'? '\n')?
;
terminal WS : 
	(' '|'\t'|'\r'|'\n')+
;
terminal ANY_OTHER : 
	.
;
