/**
 * GF Eclipse Plugin
 * http://www.grammaticalframework.org/eclipse/
 * John J. Camilleri, 2012
 * 
 * The research leading to these results has received funding from the
 * European Union's Seventh Framework Programme (FP7/2007-2013) under
 * grant agreement no FP7-ICT-247914.
 */
 
/**
 * GF grammar based on the GF Book (2011), Appendix C.6
 * Some (hopefully syntactically-equivalent) modifications have been made to please the compiler.
 */
grammar org.grammaticalframework.eclipse.GF

hidden(WS, ML_COMMENT, SL_COMMENT, COMPILER_PRAGMA, GF_DOC)
	
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
	
generate gF "http://www.grammaticalframework.org/eclipse/GF"

/*
 * This grammar basically treats a single resource (file), which is why we start directly
 * from ModDef and exclude the rules ListModDef, Grammar.

Grammar :
	ListModDef
;

ListModDef :
	{ListModDef} (modules+=ModDef)*
;
*/

ModDef :
	(incomplete?='incomplete')? type=ModType '=' body=ModBody (';')*
;

// Cross-ref checking is done by Validation, not via grammar
ModType :
		abstract?='abstract'	name=Ident
	|	resource?='resource'	name=Ident
	|	interface?='interface'	name=Ident
	|	concrete?='concrete'	name=Ident 'of' abstractName=Ident
	|	instance?='instance'	name=Ident 'of' abstractName=Ident
;

ModBody :
    {ModBody} ( (extends+=Included (',' extends+=Included)*)? '**')? ('open' (opens+=Open (',' opens+=Open)*)? 'in')? '{' (judgements+=TopDef)* '}'
	| {ModBody} (extends+=Included (',' extends+=Included)*)?
	| {ModBody} functor=Included functorInstantiation?='with' (instantiations+=Open (',' instantiations+=Open)*)?
	| {ModBody} functor=Included functorInstantiation?='with' (instantiations+=Open (',' instantiations+=Open)*)? '**' ('open' (opens+=Open (',' opens+=Open)*)? 'in')? '{' (judgements+=TopDef)* '}'
	| {ModBody} (extends+=Included (',' extends+=Included)*)? '**' functor=Included functorInstantiation?='with' (instantiations+=Open (',' instantiations+=Open)*)?
	| {ModBody} (extends+=Included (',' extends+=Included)*)? '**' functor=Included functorInstantiation?='with' (instantiations+=Open (',' instantiations+=Open)*)? '**' ('open' (opens+=Open (',' opens+=Open)*)? 'in')? '{' (judgements+=TopDef)* '}'
;

Open :
	      name=Ident
	| '(' name=Ident ')'
	| '(' alias=Ident '=' name=Ident ')'
;

Included :
	  name=Ident
	| name=Ident inclusive?=	'[' includes+=Ident (',' includes+=Ident)* ']'
	| name=Ident exclusive?='-' '[' excludes+=Ident (',' excludes+=Ident)* ']'
;

Def :
//	  name=ListName '=' definition=Exp
//	| name=Name patterns=ListPatt '=' definition=Exp
//	| name=ListName ':' type=Exp ('=' definition=Exp)?
	  name+=Name (',' name+=Name)*				 '=' definition=Exp
	| name+=Name (',' name+=Name)* ':' type=Exp ('=' definition=Exp)?
	| name+=Name patterns=ListPatt				 '=' definition=Exp
;

// For handling the overload syntax
OperDef returns Def :
	  name+=Name (',' name+=Name)*				 '=' ( definition=Exp | overload?='overload' '{' overloads+=Def (';' overloads+=Def )* ';'? '}')
	| name+=Name (',' name+=Name)* ':' type=Exp	('=' ( definition=Exp | overload?='overload' '{' overloads+=Def (';' overloads+=Def )* ';'? '}'))?
	| name+=Name (',' name+=Name)* ':' overload?='overload'	'{' overloads+=Def (';' overloads+=Def )* ';'? '}'
	| name+=Name patterns=ListPatt				 '=' definition=Exp
;

TopDef :
	  cat?='cat'		(definitions+=CatDef ';')+
	| fun?='fun'		(definitions+=FunDef ';')+
	| data?='data'		(definitions+=FunDef ';')+
	| def?='def'		(definitions+=Def ';')+
	| data?='data'		(definitions+=DataDef ';')+
	| param?='param'	(definitions+=ParDef ';')+		
//	| oper?='oper'		(definitions+=Def ';')+
	| oper?='oper'		(definitions+=OperDef ';')+
	| lincat?='lincat'	(definitions+=PrintDef ';')+
	| lindef?='lindef'	(definitions+=Def ';')+
	| lin?='lin'		(definitions+=Def ';')+
	| printname?='printname' 'cat'	(definitions+=PrintDef ';')+
	| printname?='printname' 'fun'	(definitions+=PrintDef ';')+
	| flags?='flags'	(definitions+=FlagDef ';')+
;

CatDef :
	      name=Ident context+=DDecl*
	| '[' name=Ident context+=DDecl* ']' ('{' size=Integer '}')?
;

FunDef :
	name+=Ident (',' name+=Ident)* ':' type=Exp
;

DataDef :
	name=Ident '=' (constructors+=DataConstr ('|' constructors+=DataConstr)* '|'? )?
;

DataConstr :
	  name=Ident
	| module=Ident '.' name=Ident
;

ParDef :
	  name=Ident '=' (constructors+=ParConstr ('|' constructors+=ParConstr)* '|'? )?
	| name=Ident '=' '(' 'in' id2=Ident ')'
	| name=Ident
;

ParConstr :
	name=Ident constructors+=DDecl*
;

PrintDef :
//	name=ListName '=' printname=Exp
	name+=Name (',' name+=Name)* '=' printname=Exp
;

FlagDef :
	  name=Ident '=' (value=Ident | String)
;

Name :
	name=Ident
	| '[' name=Ident ']'
;

LocDef :
	  name+=Ident (',' name+=Ident)* ':' type=Exp 	('=' value=Exp)?
	| name+=Ident (',' name+=Ident)*				 '=' value=Exp
;

ListLocDef :
	// ε | LocDef | LocDef ';' ListLocDef
	{ListLocDef} ( localDefinitions+=LocDef (';' localDefinitions+=LocDef)* ';'? )?
;

Exp6 returns Exp :
	  name=[Ident|ID]		// constant or variable
	| sort?=Sort			// type of types/param types/strings/token lists
	| builtInCat?=BuiltInCat	// TODO
	| string?=String			// string literal
	| integer?=Integer		// integer literal
	| double?=Double			// floating point literal
	| meta?='?' 		// metavariable
	| emptyString?='[' ']'		// empty token list
	| listCat?='[' category=[Ident|ID] list=Exps ']'		// list category
	| tokenList?='[' String ']'						// token list
	| record?='{' defList=ListLocDef '}'				// record / record type
	| tuple?='<' (=> tupleList=ListTupleComp | v=Exp ':' type=Exp) '>'		// tuple | type-annotated expression
	// TODO LString (?)
	| identity?='(' v=Exp ')'
;

Exp5 returns Exp :
	Exp6 ('.' label+=Label)*		// projection or qualification
;

Exp4 returns Exp :
	  'case' caseOf=Exp 'of' '{' caseList=ListCase '}'	(e+=Exp5 | '{'e+=Exp'}')*
	| 'variants' '{' expList=ListExp '}'				(e+=Exp5 | '{'e+=Exp'}')*
	| 'pre' '{' caseList=ListCase '}'					(e+=Exp5 | '{'e+=Exp'}')*
	| 'strs' '{' expList=ListExp '}'					(e+=Exp5 | '{'e+=Exp'}')*
	| '#' pattern=Patt3									(e+=Exp5 | '{'e+=Exp'}')*  // TODO Check!
	| 'lincat' name=[Ident|ID] inner=Exp5				(e+=Exp5 | '{'e+=Exp'}')*
	| 'lin' name=[Ident|ID] inner=Exp5					(e+=Exp5 | '{'e+=Exp'}')*
	| Exp5												(e+=Exp5 | '{'e+=Exp'}')*
;

Exp3 returns Exp :
	  Exp4											(('!'|'*'|'**') e+=Exp4)*
	| 'table' '{' caseList=ListCase '}'				(('!'|'*'|'**') e+=Exp4)*
	| 'table' argType=Exp6 ( '{' caseList=ListCase '}' | '[' expList=ListExp ']' )		(('!'|'*'|'**') e+=Exp4)*			// course-of-values table
//	| '#'	v=Patt2		(('!'|'*'|'**') e+=Exp4)*
;

Exp2 returns Exp :
	Exp3 ('+' e+=Exp2)*
;

Exp1 returns Exp :
	Exp2 ('++' e+=Exp1)*
;

Exp :
	 '\\' bindList=ListBind '->' v=Exp					(=> '|' e+=Exp1)*
	| '\\' '\\' bindList=ListBind '=>' v=Exp				(=> '|' e+=Exp1)*
//-	| d+=Decl '->' e+=Exp							(=> '|' e+=Exp1)*
//-	| e+=Exp3 '=>' e+=Exp							(=> '|' e+=Exp1)*
	| 'let' '{' defList=ListLocDef '}' 'in' v=Exp		(=> '|' e+=Exp1)*
	| 'let' defList=ListLocDef 'in' v=Exp				(=> '|' e+=Exp1)*
//-	| e+=Exp3 'where' '{' e+=ListLocDef '}'			(=> '|' e+=Exp1)*

 /*
 * The following is (hopefully) an amalgamation of:
 *	Decl -> Exp
 *  Exp3 => Exp
 * 	Exp3 where { ListLocDef }
 * 	Exp1
 */
	| '(' bindList=ListBind ':' type=Exp ')'	'->' v=Exp		(=> '|' e+=Exp1)*
	| v=Exp4
		(
			(('!'|'*'|'**') e+=Exp4)*				// That makes Exp3
			(
				  '=>' e+=Exp
				| 'where' '{' defList=ListLocDef '}'
				| ('+' e+=Exp2)? ('++' e+=Exp1)?
			)

			| '->' e+=Exp
		)
		(=> '|' e+=Exp1)*
		
	| '#' v=Patt2
		(('!'|'*'|'**') e+=Exp4)*				// That makes Exp3
		(
			  '=>' e+=Exp
			| 'where' '{' defList=ListLocDef '}'
			| ('+' e+=Exp2)? ('++' e+=Exp1)?
		)
		(=> '|' e+=Exp1)*
 
;

ListExp :
	// ε | Exp | Exp ';' ListExp
	{ListExp} ( expressions+=Exp (';' expressions+=Exp)* ';'? )?
;

Exps :
	// ε | Exp6 Exps
	{Exps} (expressions+=Exp6)*
;

Patt3 returns Patt :
	  '?'
	| '[' String ']'
	| '#' name=Ident
	| '#' name=Ident '.' label=Ident
	| '_'
	| name=Ident
	| name=Ident '.' label=Ident
	| Integer
	| Double
	| String
	| '{' ListPattAss '}'
	| '<' ListPattTupleComp '>'
	| '(' Patt ')'
;

Patt2 returns Patt :
	  name=Ident '@' value=Patt3
	| '-' Patt3
	| '~' Exp6
	| Patt3
;

Patt1 returns Patt :
	  name=Ident value=ListPatt
	| name=Ident '.' label=Ident value=ListPatt
	| Patt3 '*'
	| Patt2
;

Patt :
	// Patt '|' Patt1 | Patt '+' Patt1 | Patt1
	p += Patt1 (('|'|'+') p += Patt1)*
;

// "Pattern Assignment"
PattAss :
	name+=Ident (',' name+=Ident)* '=' value=Patt
;

Label :
	  name=Ident
	| '$' index=Integer
;

Sort :
	  'Type'
	| 'PType'
	| 'Tok'
	| 'Str'
	| 'Strs'
;

BuiltInCat :
	  'String'
	| 'Int'
	| 'Ints'
	| 'Float'
	| 'pattern'
;

ListPattAss :
	// ε | PattAss | PattAss ';' ListPattAss
	{ListPattAss} ( assignments+=PattAss (';' assignments+=PattAss)* ';'? )?
;

// WARNING If you refactor this, make sure to update GFScopeProvider::getAllDescriptions(), line 137
ListPatt :
	// Patt2 | Patt2 ListPatt
	(patterns += Patt2)+
;

Bind :
	  name=Ident
	| {Bind} '_'
;

// WARNING If you refactor this, make sure to update GFScopeProvider::getAllDescriptions(), line 142
ListBind :
	// ε | Bind | Bind ',' ListBind
	{ListBind} ( bindings+=Bind (',' bindings+=Bind)* )?
;

/*
 * This has now been melted down into Exp
 */ 
//Decl :
//	  '(' lb=ListBind ':' e+=Exp ')'
//	| e+=Exp4
//;
 
TupleComp :
	Exp
;

PattTupleComp :
	Patt
;

ListTupleComp :
	// ε | TupleComp | TupleComp ',' ListTupleComp
	{ListTupleComp} ( l += TupleComp (',' l += TupleComp)* )?
;

ListPattTupleComp :
	// ε | PattTupleComp | PattTupleComp ',' ListPattTupleComp
	{ListPattTupleComp} ( l += PattTupleComp (',' l += PattTupleComp)* )?
;

Case :
	pattern=Patt '=>' e=Exp
;

ListCase :
	// Case | Case ';' ListCase
	cases+=Case (';' cases+=Case)*
;

DDecl :
	  '(' bindList=ListBind ':' e=Exp ')'
	| Exp6
;

/*
 * Terminals, Comments
 * 
 * Based on (but modified from) those from org.eclipse.xtext.common.Terminals
 * Ref: http://www.eclipse.org/Xtext/documentation/2_0_0/020-grammar-language.php#grammarLanguage_6
 */
Ident : s=ID ; 
 
terminal ID : 
	('a'..'z'|'A'..'Z'|'_')('a'..'z'|'A'..'Z'|'0'..'9'|'_'|'\'')*
//	('a'..'z'|'A'..'Z'|'_')('a'..'z'|'A'..'Z'|'0'..'9'|'_'|'\'')*('.'('a'..'z'|'A'..'Z'|'_')('a'..'z'|'A'..'Z'|'0'..'9'|'_'|'\'')*)?
;
terminal String : 
	  '"' ( '\\'('"'|'\\') | !('\\'|'"') )* '"'
; 
terminal Integer returns ecore::EInt: 
	('0'..'9')+
;
terminal Double returns ecore::EDouble :
	('0'..'9')+'.'('0'..'9')+('e''-'?('0'..'9')+)?
;
terminal COMPILER_PRAGMA :
	'--#' !('\n'|'\r')* ('\r'? '\n')?
;
terminal GF_DOC :
	('--%'|'--:') !('\n'|'\r')* ('\r'? '\n')?
;
terminal ML_COMMENT :
	'{-' -> '-}'
;
terminal SL_COMMENT : 
	'--' !('\n'|'\r')* ('\r'? '\n')?
;
terminal WS : 
	(' '|'\t'|'\r'|'\n')+
;
terminal ANY_OTHER : 
	.
;
